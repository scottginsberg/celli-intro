<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Tri‑Trail Evolved • three.js</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@100;300&display=swap" rel="stylesheet">
  <style>
    :root { --bg: #000; --fg: #e6e6e6; --accent:#8ab4ff; }
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    #app { position:fixed; inset:0; background:var(--bg); z-index:60; }
    .hud { position:fixed; inset:0; pointer-events:none; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; z-index:65; }
    .brand { position:absolute; left:2rem; bottom:2rem; color:var(--fg); letter-spacing:0.08em; font-weight:600; font-size:12px; opacity:.65; text-transform:uppercase; }
    .quote { position:absolute; left:50%; top:50%; transform:translate(-50%, -50%); color:var(--fg); font-weight:300; font-size:16px; letter-spacing:0.03em; line-height:1.6; max-width:560px; width:90%; text-align:center; font-style:italic; margin:0; padding:0 20px; box-sizing:border-box; z-index:10; visibility:hidden; opacity:0; transition: color 0.45s ease, text-shadow 0.45s ease; }
    .quote__text { display:block; max-width:100%; }
    .quote.quote--loom { font-family:'Roboto Mono', ui-monospace, monospace; font-style:normal; letter-spacing:0.12em; }
    .quote.visible { animation: fadeInQuote 3s ease-out forwards; display:block !important; visibility:visible; }
    @keyframes fadeInQuote {
      0% { opacity:0; transform:translate(-50%, -50%) translateY(20px); }
      100% { opacity:.85; transform:translate(-50%, -50%) translateY(0); }
    }
    .quote.glitch { animation: glitchText 0.5s ease-in-out infinite; }
    .quote.scrambling { text-shadow: 0 0 18px rgba(138, 180, 255, 0.4); color:#f5f5f5; }
    @keyframes glitchText {
      0%, 100% { opacity:.85; transform:translate(-50%, -50%) translateX(0); text-shadow: 0 0 0 transparent; }
      10% { opacity:.8; transform:translate(-50%, -50%) translateX(-1px); text-shadow: 1px 0 #ff1e6e, -1px 0 #00a8ff; }
      20% { opacity:.9; transform:translate(-50%, -50%) translateX(1px); text-shadow: -1px 0 #ffb62e, 1px 0 #00a8ff; }
      30% { opacity:.85; transform:translate(-50%, -50%) translateX(0); text-shadow: 0 0 0 transparent; }
    }
    .quote.glitchMedium { animation: glitchMedium 0.3s ease-in-out infinite; }
    @keyframes glitchMedium {
      0%, 100% { opacity:.82; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
      15% { opacity:.7; transform:translate(-50%, -50%) translateX(-3px) translateY(1px); text-shadow: 2px 0 #ff1e6e, -2px 0 #00a8ff; }
      35% { opacity:.8; transform:translate(-50%, -50%) translateX(3px) translateY(-2px); text-shadow: -3px 0 #ffb62e, 3px 0 #00a8ff; }
      55% { opacity:.75; transform:translate(-50%, -50%) translateX(-2px) translateY(2px); text-shadow: 2px 0 #00a8ff, -2px 0 #ff1e6e; }
      75% { opacity:.78; transform:translate(-50%, -50%) translateX(2px) translateY(-1px); text-shadow: -2px 0 #ffb62e, 2px 0 #ff1e6e; }
    }
    .quote.glitchIntense { animation: glitchIntense 0.12s ease-in-out infinite; }
    @keyframes glitchIntense {
      0% { opacity:.75; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
      12% { opacity:.5; transform:translate(-50%, -50%) translateX(-8px) translateY(4px); text-shadow: 4px 0 #ff1e6e, -4px 0 #00a8ff, 0 4px #ffb62e; }
      25% { opacity:.7; transform:translate(-50%, -50%) translateX(6px) translateY(-6px); text-shadow: -6px 0 #ffb62e, 6px 0 #00a8ff, 0 -6px #ff1e6e; }
      40% { opacity:.45; transform:translate(-50%, -50%) translateX(-10px) translateY(8px); text-shadow: 8px 0 #00a8ff, -8px 0 #ff1e6e; }
      55% { opacity:.65; transform:translate(-50%, -50%) translateX(5px) translateY(-3px); text-shadow: -5px 0 #ffb62e, 5px 0 #ff1e6e; }
      70% { opacity:.55; transform:translate(-50%, -50%) translateX(-7px) translateY(5px); text-shadow: 6px 0 #00a8ff, -5px 0 #ffb62e; }
      85% { opacity:.6; transform:translate(-50%, -50%) translateX(8px) translateY(-4px); text-shadow: -7px 0 #ff1e6e, 6px 0 #00a8ff; }
      100% { opacity:.5; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
    }
    .loomworks { position:absolute; left:50%; top:50%; transform:translate(calc(-50% + var(--loomOffsetX, 0px)), calc(-50% + var(--loomOffsetY, 0px))); color:#fff; font-weight:300; font-size:20px; letter-spacing:0.15em; opacity:0; text-align:center; pointer-events:none; font-family:'Roboto Mono', ui-monospace, monospace; white-space:nowrap; }
    .loomworks.visible { animation: fadeInLoom 2s ease-out forwards; }
    .loomworks-chunk { display:inline-block; padding:0 0.08em; opacity:0; transform:translateY(12px); transition: opacity 0.45s ease, transform 0.45s ease, background 0.25s ease, color 0.25s ease; }
    .loomworks.visible .loomworks-chunk { opacity:1; transform:translateY(0); }
    .loomworks-chunk.selected { background:#fff; color:#000; box-shadow:0 0 0 1px rgba(0,0,0,0.55); }
    .loomworks-chunk.shift-right { transform:translateX(0.35em); }
    #loomTail { white-space:pre; }
    @keyframes fadeInLoom {
      0% { opacity:0; transform:translate(-50%, -50%) scale(0.95); }
      100% { opacity:1; transform:translate(-50%, -50%) scale(1); }
    }
    
    /* Doorway portal - starts as vertical bar */
    .doorway { position:fixed; left:50%; bottom:20%; transform:translate(-50%, 0); width:4px; height:60px; background:#fff; pointer-events:none; z-index:68; opacity:0; box-shadow: 0 0 15px 5px rgba(255,255,255,0.8), 0 0 30px 10px rgba(255,255,255,0.5); transition: width 1.5s cubic-bezier(0.4, 0, 0.2, 1), height 1.5s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 1.5s ease-out, opacity 0.5s ease-out; overflow:hidden; }
    .doorway.visible { opacity:1; }
    .doorway.open { width:min(280px, 85vw); height:80px; box-shadow: 0 0 40px 20px rgba(255,255,255,0.7), 0 0 80px 35px rgba(255,255,255,0.4), inset 0 0 60px rgba(255,255,255,0.6); }
    
    /* Light rays emanating from doorway - forward emission only (cut off at top) */
    .doorway::before { content:""; position:absolute; left:-150%; right:-150%; top:0%; bottom:-200%; background:radial-gradient(ellipse 120% 80% at center top, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.15) 40%, transparent 70%); opacity:0; transition:opacity 1.5s ease-out; pointer-events:none; clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); }
    .doorway.open::before { opacity:1; }
    
    /* Input prompt inside doorway */
    .prompt-container { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; opacity:0; transition:opacity 1s ease-in 1.5s; pointer-events:none; user-select:none; -webkit-user-select:none; }
    .doorway.open .prompt-container { opacity:1; pointer-events:auto; cursor:text; }
    .prompt {
      position: relative;
      font-family: 'Press Start 2P', 'Roboto Mono', ui-monospace, monospace;
      font-size: clamp(12px, 3.5vw, 36px);
      font-weight:400;
      color:#000;
      letter-spacing:0.08em;
      z-index: 2;
      white-space: nowrap;
    }
    /* Shadow trick - vertically flipped and stretched text acting as shadow */
    .prompt::after {
      content: attr(data-text);
      position: absolute;
      left: 0;
      top: 130%;
      width: 100%;
      font-family: 'Press Start 2P', 'Roboto Mono', ui-monospace, monospace;
      font-size: clamp(12px, 3.5vw, 36px);
      font-weight: 400;
      color: rgba(0, 0, 0, 0.95);
      letter-spacing: 0.08em;
      transform: scaleY(-1.4) perspective(150px) rotateX(68deg);
      transform-origin: top center;
      opacity: 0.9;
      filter: blur(1px);
      z-index: 1;
      pointer-events: none;
      white-space: nowrap;
      mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.7) 35%, rgba(0,0,0,0) 100%);
      -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.7) 35%, rgba(0,0,0,0) 100%);
    }
    .cursor { animation:blink 1s step-end infinite; }
    @keyframes blink {
      0%, 50% { opacity:1; }
      51%, 100% { opacity:0; }
    }
    
    /* CELLI glitch effects */
    .celli-glitch .char { display:inline-block; transition:opacity 0.1s; }
    .celli-glitch .char.flicker { animation:celliFlicker 0.15s infinite; }
    .celli-glitch .char.hidden { opacity:0; }
    @keyframes celliFlicker {
      0%, 100% { opacity:1; text-shadow: 0 0 8px currentColor; }
      25% { opacity:0.3; transform:translateX(-2px); }
      50% { opacity:0.6; transform:translateX(2px); }
      75% { opacity:0.2; transform:translateY(-1px); }
    }
    .screenGlitch { position:fixed; inset:0; pointer-events:none; background:#000; opacity:0; z-index:5; mix-blend-mode:normal; }
    .screenGlitch.active { animation: screenFlicker 0.2s infinite; }
    @keyframes screenFlicker {
      0%, 100% { opacity:0; background:#000; }
      15% { opacity:0.08; background:#fff; }
      30% { opacity:0; background:#000; }
      45% { opacity:0.12; background:#00a8ff; }
      60% { opacity:0; background:#000; }
      80% { opacity:0.1; background:#ff1e6e; }
    }
    .fallback { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; color:#bbb; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
    .scanlines::before { content:""; position:absolute; inset:0; pointer-events:none; background: repeating-linear-gradient( to bottom, rgba(255,255,255,0.04), rgba(255,255,255,0.04) 1px, transparent 1px, transparent 3px ); mix-blend-mode: overlay; opacity:.18; transition: opacity 1s ease; }
    .scanlines.fade-scanlines::before { opacity: 0; }
    .vignette { position:absolute; inset:0; pointer-events:none; box-shadow: inset 0 0 240px rgba(0,0,0,.75), inset 0 0 800px rgba(0,0,0,.65); }
    canvas { filter: saturate(1.06) contrast(1.06) brightness(1.02); display:block; }

    /* Play overlay */
    .play { position:fixed; inset:0; display:grid; place-items:center; background: radial-gradient(ellipse at center, rgba(30,30,30,.6) 0%, rgba(0,0,0,.9) 60%); z-index:100; }
    .play.hidden{ display:none; }
    .play button{ pointer-events:auto; appearance:none; border:none; padding:14px 20px; border-radius:999px; font-weight:700; letter-spacing:.06em; text-transform:uppercase; background:#111; color:#e8eaed; box-shadow: 0 0 0 2px rgba(255,255,255,.08) inset, 0 6px 20px rgba(0,0,0,.45); cursor:pointer; display:flex; gap:12px; align-items:center; }
    .play button::before{ content:"▶"; font-size:14px; opacity:.9; }
    
    /* Skip button */
    .skip-btn { position:fixed; bottom:20px; left:50%; transform:translate(-50%, 0); pointer-events:auto; cursor:pointer; z-index:70; opacity:0.75; display:flex; align-items:center; justify-content:center; gap:0; transition: opacity 0.45s ease; --skip-triangle-size:24px; --skip-triangle-height: calc(var(--skip-triangle-size) * 0.8660254038); }
    .skip-btn:hover { opacity:1; }
    .skip-btn.hidden { display:none; }
    .skip-btn.bow-lock { pointer-events:none; }
    .skip-triangle { position:relative; width:var(--skip-triangle-size); height:var(--skip-triangle-height); display:flex; align-items:center; justify-content:center; transition: transform 0.85s cubic-bezier(0.19, 1, 0.22, 1), filter 0.6s ease; }
    .skip-triangle__inner { width:100%; height:100%; display:flex; filter: drop-shadow(0 2px 6px rgba(255,255,255,0.55)); transform-origin:center; transition: filter 0.6s ease, transform 0.6s ease; }
    .skip-triangle--right .skip-triangle__inner { transform: scaleX(-1); }
    .skip-triangle svg { width:100%; height:100%; display:block; }
    .skip-triangle polygon, .skip-triangle path { fill:#fff; stroke:rgba(255,255,255,0.35); stroke-width:5; stroke-linejoin:round; transition: stroke 0.6s ease, fill 0.6s ease, opacity 0.5s ease; }
    .skip-triangle path { opacity:0; }
    .skip-btn:not(.bow-shape) .skip-triangle--left { transform: translateX(calc(var(--skip-triangle-size) * -0.5)); }
    .skip-btn:not(.bow-shape) .skip-triangle--right { transform: translateX(calc(var(--skip-triangle-size) * 0.5)); }
    .skip-btn.bow-shape { gap:0; opacity:1; --skip-triangle-size:30px; }
    .skip-btn.bow-shape .skip-triangle { position:absolute; top:50%; left:50%; margin:0; }
    .skip-btn.bow-shape .skip-triangle__inner { filter: drop-shadow(0 4px 10px rgba(255,255,255,0.5)) drop-shadow(0 0 18px rgba(255,255,255,0.35)); }
    .skip-btn.bow-shape .skip-triangle--left { transform: translate(-50%, -50%) translateX(calc(var(--skip-triangle-size) * -0.5)); }
    .skip-btn.bow-shape .skip-triangle--right { transform: translate(-50%, -50%) translateX(calc(var(--skip-triangle-size) * 0.5)); }
    .skip-btn.bow-shape .skip-triangle--right .skip-triangle__inner { transform: scaleX(1); }
    .skip-connector { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:0; height:0; border-radius:0; background:transparent; box-shadow:none; opacity:0; transition: all 0.6s ease; pointer-events:none; }
    .skip-btn.rounded-bow .skip-triangle polygon { opacity:0; }
    .skip-btn.rounded-bow .skip-triangle path { opacity:1; }
    .skip-btn.rounded-bow .skip-connector { width:calc(var(--skip-triangle-size) * 0.45); height:calc(var(--skip-triangle-size) * 0.45); border-radius:calc(var(--skip-triangle-size) * 0.12); background:rgba(255,255,255,0.92); box-shadow:0 0 14px rgba(255,255,255,0.55), 0 0 20px rgba(138,180,255,0.45); opacity:1; }
    .skip-btn.illuminating .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite; }
    .skip-btn.illuminating.bow-shape .skip-triangle--left .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite, skipJiggleLeft 1.6s ease-in-out infinite; }
    .skip-btn.illuminating.bow-shape .skip-triangle--right .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite, skipJiggleRight 1.6s ease-in-out infinite; }
    .skip-btn.illuminating.rounded-bow .skip-connector { animation: skipCenterPulse 2.2s ease-in-out infinite; }
    .skip-btn.illuminating .skip-triangle polygon { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
    .skip-btn.illuminating.rounded-bow .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }

    @keyframes skipGlowPulse {
      0%, 100% { filter: drop-shadow(0 4px 10px rgba(255,255,255,0.5)) drop-shadow(0 0 18px rgba(138,180,255,0.45)); }
      45% { filter: drop-shadow(0 6px 18px rgba(255,255,255,0.75)) drop-shadow(0 0 26px rgba(138,180,255,0.7)); }
      55% { filter: drop-shadow(0 5px 14px rgba(255,255,255,0.65)) drop-shadow(0 0 22px rgba(255,182,46,0.55)); }
    }
    @keyframes skipFillShimmer {
      0%, 100% { fill:#ffffff; }
      25% { fill:#f5f9ff; }
      50% { fill:#ffffff; }
      75% { fill:#eef3ff; }
    }
    @keyframes skipOutlinePulse {
      0%, 100% { stroke:rgba(138,180,255,0.45); stroke-width:5; }
      40% { stroke:rgba(255,255,255,0.85); stroke-width:6.5; }
      60% { stroke:rgba(255,182,46,0.7); stroke-width:6; }
    }
    @keyframes skipJiggleLeft {
      0%, 100% { transform: translate(0, 0); }
      40% { transform: translate(-6%, -6%); }
      70% { transform: translate(4%, 4%); }
    }
    @keyframes skipJiggleRight {
      0%, 100% { transform: translate(0, 0); }
      40% { transform: translate(6%, -5%); }
      70% { transform: translate(-4%, 4%); }
    }
    @keyframes skipCenterPulse {
      0%, 100% { box-shadow:0 0 16px rgba(255,255,255,0.6), 0 0 24px rgba(255,255,255,0.35); }
      45% { box-shadow:0 0 26px rgba(138,180,255,0.75), 0 0 36px rgba(255,255,255,0.6); }
      65% { box-shadow:0 0 24px rgba(255,182,46,0.65), 0 0 34px rgba(255,255,255,0.5); }
    }

    .visicell-note-line { display:inline-block; min-width:1ch; opacity:0; transform:translateY(6px); animation: visicellNoteSlide 0.6s ease forwards; }
    .visicell-note-line--1 { animation-delay:0.2s; }
    .visicell-note-line--2 { animation-delay:0.45s; }
    @keyframes visicellNoteSlide {
      from { opacity:0; transform:translateY(10px); }
      to { opacity:1; transform:translateY(0); }
    }

    /* Debug toast */
    .toast{ position:fixed; right:14px; top:14px; background:rgba(18,18,18,.9); color:#cbd5e1; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:10px 12px; font: 12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; z-index: 9; box-shadow: 0 10px 24px rgba(0,0,0,.35); pointer-events:none; opacity:.95; max-width: 42ch; }
    .toast strong{ color:#fff; font-weight:700; }
    .toast .ok{ color:#9ae6b4; }
    .toast .warn{ color:#f6e05e; }
    .toast .err{ color:#feb2b2; }
    .r-hint { transition: text-shadow 0.6s ease, opacity 0.6s ease; text-shadow: none; }
    .r-hint.glow { text-shadow: 0 0 8px #0f0, 0 0 16px #0f0; }
    .r-hint .r-line { display:block; line-height:1.4; }
    .r-hint .r-char { display:inline-block; width:1ch; transition: transform 0.85s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.85s ease, filter 0.85s ease; }
    .r-hint .r-char.falling { transform: translateY(26px); opacity:0; filter: blur(2px); }
  </style>
</head>
<body>
  <div id="app" class="scanlines"></div>
  <div class="hud">
    <div id="quote" class="quote">
      <span id="quoteBefore" class="quote__text">...if you gaze for long into an abyss, the abyss gazes also into you.</span>
      <span id="quoteAfter" class="quote__text" style="display:none;"></span>
    </div>
    <div id="loomworks" class="loomworks" aria-live="polite">
      <span id="loomPre" class="loomworks-chunk">L</span><span id="loomCore" class="loomworks-chunk">OO</span><span id="loomPost" class="loomworks-chunk">K</span><span id="loomTail" class="loomworks-chunk"></span>
    </div>
    <span id="floatingK" class="floatingK" aria-hidden="true">K</span>
    <div class="vignette"></div>
  </div>
  <div id="screenGlitch" class="screenGlitch"></div>
  
  <!-- Doorway portal -->
  <div id="doorway" class="doorway">
    <div class="prompt-container">
      <div class="prompt" data-text="=STAR_"><span id="promptText">=STAR</span><span id="promptCursor" class="cursor">_</span></div>
    </div>
  </div>
  
  <!-- Hidden input for mobile keyboard -->
  <input id="hiddenInput" type="text" style="position:absolute; left:-9999px; opacity:0;" autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false" inputmode="text" enterkeyhint="done" />
  
  <audio id="chime" preload="auto">
    <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=" type="audio/wav">
  </audio>
  <div id="fallback" class="fallback" style="display:none">⚠️ WebGL unavailable or ES Modules not supported. Try a newer browser/GPU.</div>

  <div id="play" class="play"><button id="playBtn">Play</button></div>
    <div id="skipBtn" class="skip-btn hidden" role="button" aria-label="Skip intro" tabindex="0">
        <div class="skip-triangle skip-triangle--left" id="skipTriangle1">
          <div class="skip-triangle__inner">
            <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
              <polygon points="0,0 0,86.6025403784 100,43.3012701892"></polygon>
              <path d="M0,12 L0,74.6025403784 Q0,86.6025403784 11.012,81.8342402525 L88.988,48.0696001263 Q100,43.3012701892 88.988,38.5329402521 L11.012,4.7679001263 Q0,0 0,12 Z"></path>
            </svg>
          </div>
        </div>
        <div class="skip-connector" id="skipConnector" aria-hidden="true"></div>
        <div class="skip-triangle skip-triangle--right" id="skipTriangle2">
          <div class="skip-triangle__inner">
            <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
              <polygon points="100,0 100,86.6025403784 0,43.3012701892"></polygon>
              <path d="M100,12 L100,74.6025403784 Q100,86.6025403784 88.988,81.8342402525 L11.012,48.0696001263 Q0,43.3012701892 11.012,38.5329402521 L88.988,4.7679001263 Q100,0 100,12 Z"></path>
            </svg>
          </div>
        </div>
    </div>
  <div id="toast" class="toast" style="display:none"></div>

  <!-- Import map so bare specifiers resolve to CDN modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    // --- Imports ------------------------------------------------------------
    import * as THREE from "three";
    import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
    import { AfterimagePass } from "three/examples/jsm/postprocessing/AfterimagePass.js";
    import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
    import { RoundedBoxGeometry } from "three/examples/jsm/geometries/RoundedBoxGeometry.js";

    // --- Debug helpers ------------------------------------------------------
    const toastEl = document.getElementById('toast');
    function toast(lines, level='ok'){
      const arr = Array.isArray(lines) ? lines : [String(lines)];
      toastEl.innerHTML = `<strong>Debug</strong><br>${arr.map(l=>`<span class="${level}">${l}</span>`).join('<br>')}`;
      toastEl.style.display='block';
    }
    function clearToast(){ toastEl.style.display='none'; }

    // --- WebGL capability check --------------------------------------------
    const hasWebGL = (() => { try { const c = document.createElement('canvas'); return !!(window.WebGLRenderingContext && (c.getContext('webgl2')||c.getContext('webgl')||c.getContext('experimental-webgl'))); } catch(e){ return false; } })();
    if (!hasWebGL) { document.getElementById('fallback').style.display = 'flex'; throw new Error('WebGL not available'); }

    // --- Core setup ---------------------------------------------------------
    const app = document.getElementById('app');
    const quoteEl = document.getElementById('quote');
    const quoteBefore = document.getElementById('quoteBefore');
    const quoteAfter = document.getElementById('quoteAfter');
    const loomworksEl = document.getElementById('loomworks');
    const loomPre = document.getElementById('loomPre');
    const loomCore = document.getElementById('loomCore');
    const loomPost = document.getElementById('loomPost');
    const loomTail = document.getElementById('loomTail');
    const quoteStates = {
        initial: {
            text: '...if you gaze for long into an abyss, the abyss gazes also into you.',
            showLook: false
        },
        look: {
            text: '...if you LOOK for long into an abyss, the abyss LOOKS also into you.',
            showLook: false
        },
        despair: {
            text: 'LOOK on my works, ye Mighty, and despair!',
            showLook: false
        }
    };

    applyQuoteState(quoteStates.initial, { immediate: true });
    quoteEl.classList.remove('quote--loom');
    loomTail.innerHTML = '';
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.setClearColor(0x000000, 1);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 10);
    camera.position.set(0, 0, 2);
    camera.lookAt(0, 0, 0);

     const blackHoleGeo = new THREE.CircleGeometry(0.35, 64);
    const blackHoleMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 }, pulseFactor: { value: 0.5 } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `
            varying vec2 vUv; uniform float time; uniform float pulseFactor;
            void main() {
                vec2 center = vec2(0.5);
                float dist = distance(vUv, center);
                 // Organic pulsing with multiple harmonics
                 float baseRadius = 0.08 + pulseFactor * 0.28;
                 float pulse1 = 0.015 * sin(time * 3.5);
                 float pulse2 = 0.008 * sin(time * 7.3 + 1.5);
                 float radius = baseRadius + pulse1 + pulse2;
                 // Ultra-soft gradient fade for dreamy quality
                 float fadeDistance = radius * 1.6;
                float alpha = 1.0 - smoothstep(radius - fadeDistance, radius, dist);
                 // Softer alpha curve with slight glow at edges
                 alpha = pow(alpha, 0.6) * 0.9;
                 gl_FragColor = vec4(0.0, 0.0, 0.0, alpha);
            }
        `,
        transparent: true, depthWrite: false
    });
    const blackHole = new THREE.Mesh(blackHoleGeo, blackHoleMat);
    blackHole.position.z = 0.1;
    scene.add(blackHole);

    const R = 0.16;
    const makeMat = (hex) => new THREE.MeshBasicMaterial({ color: new THREE.Color(hex), blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
    const CYAN = 0x00a8ff, MAGENTA = 0xff1e6e, YELLOW = 0xffb62e;
    const colors = [new THREE.Color(CYAN), new THREE.Color(YELLOW), new THREE.Color(MAGENTA)];
    
    // Create custom rounded shapes: square (cyan), triangle (yellow), circle (magenta)
    
    // Shape 0: Rounded Square (Blue/Cyan)
    const createRoundedSquare = (size, radius) => {
        const shape = new THREE.Shape();
        const r = radius;
        const s = size / 2;
        shape.moveTo(-s + r, -s);
        shape.lineTo(s - r, -s);
        shape.quadraticCurveTo(s, -s, s, -s + r);
        shape.lineTo(s, s - r);
        shape.quadraticCurveTo(s, s, s - r, s);
        shape.lineTo(-s + r, s);
        shape.quadraticCurveTo(-s, s, -s, s - r);
        shape.lineTo(-s, -s + r);
        shape.quadraticCurveTo(-s, -s, -s + r, -s);
        return new THREE.ShapeGeometry(shape, 32);
    };
    
    // Shape 1: Rounded Triangle (Yellow) - flat bottom, pointing up
    const createRoundedTriangle = (size, radius) => {
        const shape = new THREE.Shape();
        const h = size * Math.sqrt(3) / 2; // Equilateral triangle height
        
        // Three vertices of equilateral triangle with FLAT BOTTOM
        const top = { x: 0, y: h / 2 };              // Top vertex (pointing up)
        const bl = { x: -size/2, y: -h / 2 };        // Bottom left
        const br = { x: size/2, y: -h / 2 };         // Bottom right
        
        const r = radius * 0.8; // Smaller radius for cleaner corners
        
        // Start at bottom-left, move clockwise
        shape.moveTo(bl.x + r, bl.y);
        
        // Bottom edge to bottom-right
        shape.lineTo(br.x - r, br.y);
        
        // Curve around bottom-right corner
        shape.quadraticCurveTo(br.x, br.y, br.x - r * 0.5, br.y + r * 0.866);
        
        // Right edge going up to top
        shape.lineTo(top.x + r * 0.5, top.y - r * 0.866);
        
        // Curve around top corner
        shape.quadraticCurveTo(top.x, top.y, top.x - r * 0.5, top.y - r * 0.866);
        
        // Left edge going down to bottom-left
        shape.lineTo(bl.x + r * 0.5, bl.y + r * 0.866);
        
        // Curve around bottom-left corner
        shape.quadraticCurveTo(bl.x, bl.y, bl.x + r, bl.y);
        
        return new THREE.ShapeGeometry(shape, 32);
    };
    
    // Shape 2: Circle (Pink/Magenta)
    const createCircle = (radius) => {
        return new THREE.CircleGeometry(radius, 64);
    };
    
    const geoSquare = createRoundedSquare(R * 2, R * 0.3);
    const geoTriangle = createRoundedTriangle(R * 2, R * 0.35);
    const geoCircle = createCircle(R);
    
    // Store original geometries for morphing
    const originalGeos = [geoSquare, geoTriangle, geoCircle];
    
    // Create circle targets for morphing (all shapes will become circles)
    const circleGeoTarget = createCircle(R);
    
    const spheres = [
        new THREE.Mesh(geoSquare, makeMat(CYAN)),
        new THREE.Mesh(geoTriangle, makeMat(YELLOW)),
        new THREE.Mesh(geoCircle, makeMat(MAGENTA))
    ];
    spheres.forEach((s,i)=>{ s.position.z = -i*0.002; scene.add(s); });

    // --- Voxel System for CELLI ---
    const voxelSize = 0.08;
    const voxelGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
    const voxelMat = new THREE.MeshBasicMaterial({ 
        color: 0x444444,  // Start as dim gray
        transparent: true, 
        opacity: 0,
        blending: THREE.NormalBlending  // Normal blending for borders
    });
    
    // Create edges geometry for borders
    const edgesGeo = new THREE.EdgesGeometry(voxelGeo);
    const edgeMat = new THREE.LineBasicMaterial({ 
        color: 0x888888,
        transparent: true,
        opacity: 0
    });
    
        const roundedVoxelGeo = new RoundedBoxGeometry(voxelSize * 1.1, voxelSize * 1.1, voxelSize * 0.3, 5, Math.min(voxelSize * 0.6, 0.06));
    const roundedEdgesGeo = new THREE.EdgesGeometry(roundedVoxelGeo);
    const cellShadeBaseMaterial = new THREE.MeshBasicMaterial({
        color: 0xfff27a,
        transparent: true,
        opacity: 0.92,
        blending: THREE.AdditiveBlending
    });
    const cellShadeEdgeMaterial = new THREE.LineBasicMaterial({
        color: 0xfff9a1,
        transparent: true,
        opacity: 0.75
    });

// CELLI letter patterns (5x5 grid for each letter)
    const celliPatterns = {
        C: [[0,1,1,1,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [0,1,1,1,0]],
        E: [[1,1,1,1,1], [1,0,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,1,1,1]],
        L: [[1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [1,1,1,1,1]],
        I: [[1,1,1,1,1], [0,0,1,0,0], [0,0,1,0,0], [0,0,1,0,0], [1,1,1,1,1]]
    };
    
    const voxels = [];
    const letterVoxels = { C: [], E: [], L1: [], L2: [], I: [] }; // Track voxels by letter
    const letters = ['C', 'E', 'L', 'L', 'I'];
    let letterSpacing = 0.6;
    let celliScale = 1.0;
    
    // Responsive scaling for touch devices
    function calculateCelliScale() {
        const aspect = window.innerWidth / window.innerHeight;
        
        // Calculate total width needed for all letters (including padding)
        const totalBaseWidth = letters.length * letterSpacing;
        
        // Camera view width in world units
        let viewWidth;
        if (aspect > 1) {
            // Landscape
            viewWidth = aspect * 2;
        } else {
            // Portrait
            viewWidth = 2;
        }
        
        // Scale to fit 85% of view width
        const targetWidth = viewWidth * 0.85;
        if (totalBaseWidth > targetWidth) {
            celliScale = targetWidth / totalBaseWidth;
        } else {
            celliScale = 1.0;
        }
    }
    calculateCelliScale();
    
    const startX = -(letters.length * letterSpacing * celliScale) / 2 + (letterSpacing * celliScale) / 2;
    
    letters.forEach((letter, letterIdx) => {
        const pattern = celliPatterns[letter];
        const letterX = startX + letterIdx * letterSpacing * celliScale;
        
        pattern.forEach((row, rowIdx) => {
            row.forEach((cell, colIdx) => {
                if (cell === 1) {
                    // Create voxel with border
                    const voxel = new THREE.Mesh(voxelGeo, voxelMat.clone());
                    const edges = new THREE.LineSegments(edgesGeo, edgeMat.clone());
                    voxel.add(edges);
                    
                    const x = letterX + (colIdx - 2) * voxelSize * 1.2 * celliScale;
                    const y = (2 - rowIdx) * voxelSize * 1.2 * celliScale + 0.35; // Offset up
                    
                    voxel.userData = {
                        targetX: x,
                        targetY: y,
                        startY: y + 2.0 + Math.random() * 1.0,
                        dropDelay: letterIdx * 0.15 + (rowIdx * colIdx) * 0.02,
                        dropSpeed: 0.02 + Math.random() * 0.01,
                        settled: false,
                        jigglePhase: Math.random() * Math.PI * 2,
                        flickerPhase: Math.random() * Math.PI * 2,
                        edges: edges,  // Store reference to edges
                        gridX: letterIdx,  // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)
                        gridY: rowIdx,     // Row index (0=top, 4=bottom)
                        gridCol: colIdx,   // Column index within letter (0-4)
                        glitched: false,    // Track if this voxel has been glitched out
                        baseScale: celliScale,  // Store scale for proper sizing
                        backspaceTransformed: false,
                        backspacePulseOffset: Math.random() * Math.PI * 2
                    };
                    
                    // Scale voxel size to match the overall scale
                    voxel.scale.set(celliScale, celliScale, celliScale);
                    
                    voxel.position.set(x, voxel.userData.startY, 0);
                    voxel.visible = false;
                    scene.add(voxel);
                    voxels.push(voxel);
                    
                    // Track voxels by letter for restoration
                    const letterKey = letterIdx === 0 ? 'C' : letterIdx === 1 ? 'E' : letterIdx === 2 ? 'L1' : letterIdx === 3 ? 'L2' : 'I';
                    letterVoxels[letterKey].push(voxel);
                }
            });
        });
    });

    // --- [NEW] Shader for the color triangle between spheres ---
    const triGeo = new THREE.PlaneGeometry(4, 4); // Covers view
    const triMat = new THREE.ShaderMaterial({
        uniforms: {
            points: { value: [new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()] },
            colors: { value: colors },
            aspect: { value: 1.0 }
        },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
        fragmentShader: `
            varying vec2 vUv;
            uniform vec2 points[3];
            uniform vec3 colors[3];
            uniform float aspect;

            // Function to calculate barycentric coordinates
            vec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c) {
                vec2 v0 = b - a, v1 = c - a, v2 = p - a;
                float d00 = dot(v0, v0);
                float d01 = dot(v0, v1);
                float d11 = dot(v1, v1);
                float d20 = dot(v2, v0);
                float d21 = dot(v2, v1);
                float denom = d00 * d11 - d01 * d01;
                float v = (d11 * d20 - d01 * d21) / denom;
                float w = (d00 * d21 - d01 * d20) / denom;
                float u = 1.0 - v - w;
                return vec3(u, v, w);
            }

            void main() {
                // Adjust UVs to be centered and handle aspect ratio
                vec2 p = (vUv - 0.5) * 2.0;
                p.x *= aspect;

                vec3 b = barycentric(p, points[0], points[1], points[2]);

                if (b.x >= 0.0 && b.y >= 0.0 && b.z >= 0.0) {
                    // We are inside the triangle
                    vec3 color = b.x * colors[0] + b.y * colors[1] + b.z * colors[2];
                    
                     // More defined edges with softer interior
                     float edgeDist = min(b.x, min(b.y, b.z));
                     float edgeFade = smoothstep(0.0, 0.2, edgeDist);
                     
                     // Distance-based fading
                     float centerDist = length(p);
                     float centerFade = 1.0 - smoothstep(0.15, 0.65, centerDist);
                     centerFade = pow(centerFade, 0.6);
                     
                     // Subtle center glow
                     float centerGlow = 1.0 - smoothstep(0.0, 0.25, centerDist);
                     float finalAlpha = (edgeFade * centerFade + centerGlow * 0.12) * 0.55;
                     
                     gl_FragColor = vec4(color, finalAlpha);
                } else {
                    discard;
                }
            }
        `,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const triMesh = new THREE.Mesh(triGeo, triMat);
    triMesh.position.z = -0.1; // Behind spheres
    scene.add(triMesh);

    // --- Composer & passes --------------------------------------------------
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.9, 0.2);
    composer.addPass(bloomPass);
    const afterimagePass = new AfterimagePass(0.96);
    composer.addPass(afterimagePass);
    const filmPass = new ShaderPass({
      uniforms: { tDiffuse: { value: null }, time: { value: 0 }, noise: { value: 0.03 }, scanAmp: { value: 0.03 } },
      vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader: `
        precision highp float; varying vec2 vUv; uniform sampler2D tDiffuse; uniform float time; uniform float noise; uniform float scanAmp;
        float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
        void main(){ vec3 col = texture2D(tDiffuse, vUv).rgb; float n = rand(vUv + fract(time)); float scan = sin((vUv.y + time*0.04)*3.14159*480.0) * scanAmp; col += n*noise; col += scan; col = pow(col, vec3(1.02)); gl_FragColor = vec4(col, 1.0); }`
    });
    composer.addPass(filmPass);

    // --- [REWRITTEN] Eclipse & Radiate Motion with Intro Sequence ----------
    const motionCfg = {
        speed: 0.8,
        maxDist: 0.65,
        rotationSpeed: 0.4,
        minScale: 0.4
    };

    // Intro sequence with magical progression
    const introCfg = {
        rollEnd: 2.5,        // Roll into place (slower)
        bounceEnd: 4.5,      // Sequential bounces
        triangleEnd: 7.5,    // Form triangle + grow + converge
        transitionEnd: 9.5,  // Transition to orbit
        normalEnd: 15.5,     // Converge + one pulse cycle
        vennEnd: 18.0,       // Clear venn diagram
        collapseEnd: 22.0,   // Collapse to white circle (extended)
        glitchEnd: 24.5,     // Intense glitch + fade (extended)
        blackoutEnd: 26.0,   // Complete blackout
        loomworksEnd: 30.0,  // Show Loomworks text
        celliEnd: 36.0,      // CELLI voxel animation
        doorwayEnd: 44.0,    // Doorway portal sequence
        ballSize: 0.12,      // Size during intro
        bounceHeight: 0.35,  // Bounce amplitude
        bounceDuration: 0.6  // Each bounce duration
    };
    
    // Audio context for synth and chime
    let audioCtx = null;
    let synthGain = null;
    let synthOsc1 = null;
    let synthOsc2 = null;
    let synthOsc3 = null;
    let landingSounds = [false, false, false]; // Track if shape has landed
    let lastThunkTime = [0, 0, 0]; // Track last thunk time for each shape
    
    let quoteShown = false;
    let quoteDespairShown = false;
    let glitchStarted = false;
    let mediumGlitchStarted = false;
    let intenseGlitchStarted = false;
    let screenGlitchStarted = false;
    let blackoutStarted = false;
    let loomworksShown = false;
    let loomworksRevealStarted = false;
    let chimePlayed = false;
    let celliStarted = false;
    let celliStartTime = 0;
    let doorwayShown = false;
    let doorwayOpened = false;
    let inputAttempted = false;
    let celliGlitchStarted = false;
    let finalRollRotations = [0, 0, 0]; // Store final rotations from roll phase
    const promptBaseText = '=';
    let inputText = '=STAR';
    let tEntered = false;
    let burstAnimStarted = false;
    let burstTimeout = null;
    let celliBackspaceSequenceStarted = false;
    let celliBackspaceSequenceTime = 0;
    let celliBackspaceFlickerTriggered = false;
    const starParticles = []; // Stars from burst voxels
    let loomworksTypingTimeout = null;
    const glitchedVoxelsStack = []; // Track glitched voxels in order for restoration
    let lettersToRestore = ['C', 'E', 'L1', 'L2']; // Order of restoration on backspace
    let restoredLetters = 0;
    let endSequence = ''; // Track E, N, D input sequence
    let allYellowTransformed = false; // Track if all are yellow and transformed
    let yellowTransformCompleteCount = 0;
    let endColorState = 'yellow'; // Track current color state: yellow, magenta, cyan, green
    let endColorPrevState = 'yellow'; // Track previous color for transitions
    let endColorTransitionStart = 0; // When color transition started
    let snapTogetherStarted = false;
    let snapTogetherTime = 0;
    let visiCalcShown = false;
    let celliMoveToCornerStarted = false;
    let celliMoveToCornerTime = 0;
    let visiCalcGreenTransitionStarted = false; // Track when VisiCalc green transition begins
    let bowActive = false;
    let bowCurrentCenter = null;
    let bowTargetCenter = null;
    let bowAnimationId = 0;
    let bowHasTriggered = false;
    let pendingRoundedBow = false;
    
    // Text particle system for click interactions
    const textParticles = [];
    const manicTexts = ["huh?", "who's there?", "AH!", "HAHA.", "ow.", "ahh...", "oh!", "what?", "why?", "where?", "when?"];
    const timeTexts = () => {
        const formats = [
            new Date().toLocaleTimeString(),
            new Date().toLocaleDateString(),
            `${new Date().getHours()}:${String(new Date().getMinutes()).padStart(2,'0')}`,
            new Date().getFullYear().toString(),
            `${Math.floor(Date.now()/1000)}`,
            new Date().toISOString().split('T')[0]
        ];
        return formats[Math.floor(Math.random() * formats.length)];
    };
    const equationTexts = [
        "x²+y²=r²", "∫f(x)dx", "E=mc²", "∂f/∂x", "Σ(x)", "√(a²+b²)",
        "(0,0)", "(x,y,z)", "[1,2,3]", "θ=arctan(y/x)", "∇×F", "dy/dx"
    ];

    const glitchGlyphs = "!<>-_\\/[]{}—=+*^?#▒▓█▞▚";

    function glitchSwapQuote(targetState, { duration = 1100, onComplete = null } = {}) {
        if (!targetState) return;
        if (quoteEl.dataset.swapping === '1') return;

        quoteEl.dataset.swapping = '1';
        quoteEl.classList.add('scrambling');

        const initialText = quoteBefore.textContent || '';
        const targetText = targetState.text || '';
        const textMax = Math.max(initialText.length, targetText.length);
        const textDenom = textMax === 0 ? 1 : textMax;
        const start = performance.now();

        const frame = (now) => {
            const elapsed = now - start;
            const progress = Math.min(elapsed / duration, 1);
            let result = '';

            for (let i = 0; i < textMax; i++) {
                if (progress > i / textDenom) {
                    result += targetText[i] ?? '';
                } else {
                    const fallback = initialText[i] ?? '';
                    const randomChar = glitchGlyphs[Math.floor(Math.random() * glitchGlyphs.length)] || fallback;
                    result += randomChar;
                }
            }

            quoteBefore.textContent = result;

            if (progress < 1) {
                requestAnimationFrame(frame);
            } else {
                quoteBefore.textContent = targetText;

                quoteEl.classList.remove('scrambling');
                delete quoteEl.dataset.swapping;

                if (typeof onComplete === 'function') {
                    onComplete();
                }
            }
        };

        requestAnimationFrame(frame);
    }

    function applyQuoteState(state, { immediate = false, duration, onComplete } = {}) {
        if (!state) return;

        if (immediate) {
            quoteBefore.textContent = state.text || '';
            quoteAfter.textContent = '';
            quoteEl.classList.remove('scrambling');
            delete quoteEl.dataset.swapping;
            if (typeof onComplete === 'function') {
                onComplete();
            }
            return;
        }

        glitchSwapQuote(state, { duration, onComplete });
    }

    function typeLoomTail(text, index = 0) {
        if (index === 0) {
            loomTail.innerHTML = '';
        }

        if (index >= text.length) {
            loomworksTypingTimeout = null;
            return;
        }

        // Wrap each character in a span
        const charSpan = document.createElement('span');
        charSpan.textContent = text[index];
        charSpan.className = 'loomworks-chunk selected';
        loomTail.appendChild(charSpan);
        
        // Remove selected class from this character only
        setTimeout(() => {
            charSpan.classList.remove('selected');
        }, 140);
        
        const baseDelay = index < 3 ? 110 : 65;
        const jitter = Math.random() * 55;
        loomworksTypingTimeout = setTimeout(() => typeLoomTail(text, index + 1), baseDelay + jitter);
    }


    function startLoomworksReveal() {
        if (loomworksRevealStarted) return;
        loomworksRevealStarted = true;

        loomworksEl.classList.add('visible');
        loomPre.textContent = 'L';
        loomCore.textContent = 'OO';
        loomPost.textContent = 'K';
        loomTail.innerHTML = '';

        setTimeout(() => {
            loomCore.classList.add('selected');
        }, 280);

        setTimeout(() => {
            loomCore.textContent = 'oo';
        }, 630);

        setTimeout(() => {
            loomCore.classList.remove('selected');
        }, 1080);

        setTimeout(() => {
            loomPost.classList.add('shift-right');
        }, 900);

        setTimeout(() => {
            loomPost.classList.add('selected');
            loomPost.style.opacity = '0.2';
        }, 980);

        setTimeout(() => {
            loomPost.textContent = 'm';
            loomPost.style.opacity = '1';
            loomPost.classList.remove('shift-right');
        }, 1340);

        setTimeout(() => {
            loomPost.classList.remove('selected');
            setTimeout(() => { loomPost.style.opacity = ''; }, 220);
        }, 1680);

        setTimeout(() => {
            loomPre.style.opacity = '0';
        }, 920);

        setTimeout(() => {
            loomPre.textContent = 'a L';
            loomPre.style.opacity = '1';
        }, 1340);

        setTimeout(() => {
            if (loomworksTypingTimeout) {
                clearTimeout(loomworksTypingTimeout);
            }
            typeLoomTail('works Experience.');
        }, 1380);
    }
    
    function createTextParticle(x, y, text, color, sourceIndex) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.004 + Math.random() * 0.006;
        const particle = {
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            text,
            color,
            life: 1.0,
            age: 0,
            rotation: (Math.random() - 0.5) * 0.03,
            rotationSpeed: (Math.random() - 0.5) * 0.02,
            pulse: Math.random() * Math.PI * 2,
            sourceIndex,
            collapsing: false
        };
        textParticles.push(particle);
    }
    
    function updateTextParticles(dt) {
        for (let i = textParticles.length - 1; i >= 0; i--) {
            const p = textParticles[i];
            
            p.age += dt;
            
            // Get source sphere position
            const source = spheres[p.sourceIndex].position;
            
            // Calculate attraction to source (gravitational pull)
            const dx = source.x - p.x;
            const dy = source.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // After 1.8 seconds, begin dramatic collapse
            if (p.age > 1.8 && !p.collapsing) {
                p.collapsing = true;
            }
            
            if (p.collapsing) {
                // Dramatic collapse: strong pull, wild rotation, rapid fade
                const collapseForce = 0.0008 / (dist * dist + 0.01); // Much stronger!
                p.vx += (dx / dist) * collapseForce;
                p.vy += (dy / dist) * collapseForce;
                
                // Accelerate rotation
                p.rotationSpeed *= 1.05;
                
                // Rapid fade during collapse
                p.life -= dt * 2.5;
            } else {
                // Normal orbit phase
                if (dist > 0.01) {
                    const force = 0.00008 / (dist + 0.1);
                    p.vx += (dx / dist) * force;
                    p.vy += (dy / dist) * force;
                }
                
                // Apply orbital motion
                const orbitForce = 0.00012;
                p.vx += -dy * orbitForce;
                p.vy += dx * orbitForce;
                
                // Normal fade
                p.life -= dt * 0.5;
            }
            
            // Update position
            p.x += p.vx;
            p.y += p.vy;
            
            // Damping (less during collapse for dramatic effect)
            const dampFactor = p.collapsing ? 0.97 : 0.99;
            p.vx *= dampFactor;
            p.vy *= dampFactor;
            
            // Update rotation and pulse
            p.rotation += p.rotationSpeed;
            p.pulse += dt * (p.collapsing ? 8 : 4); // Faster pulse during collapse
            
            if (p.life <= 0) {
                textParticles.splice(i, 1);
            }
        }
    }
    
    function renderTextParticles(ctx, camera) {
        ctx.save();
        ctx.font = 'bold 16px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (const p of textParticles) {
            // Project from world to screen
            const screenX = (p.x / camera.right) * (window.innerWidth / 2) + (window.innerWidth / 2);
            const screenY = (-p.y / camera.top) * (window.innerHeight / 2) + (window.innerHeight / 2);
            
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(p.rotation);
            
            const alpha = p.life * p.life;
            const pulseFactor = 0.85 + Math.sin(p.pulse) * 0.15; // Gentle pulsate
            const glowSize = 5 + Math.sin(p.pulse * 0.7) * 3; // Slower, dreamy pulse
            
            // Scale down dramatically during collapse
            const scaleFactor = p.collapsing ? Math.max(0.1, 1.0 - (p.age - 1.8) * 1.2) : 1.0;
            ctx.scale(scaleFactor, scaleFactor);
            
            // Outer colored glow - intensify during collapse
            const collapseIntensity = p.collapsing ? 1.5 : 1.0;
            ctx.shadowBlur = glowSize * 4 * collapseIntensity;
            ctx.shadowColor = p.color;
            ctx.globalAlpha = alpha * 0.9 * collapseIntensity;
            ctx.fillStyle = p.color;
            ctx.fillText(p.text, 0, 0);
            
            // Mid white glow for visibility
            ctx.shadowBlur = glowSize * 2;
            ctx.shadowColor = '#ffffff';
            ctx.globalAlpha = alpha * 0.95;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(p.text, 0, 0);
            
            // Bright white base (always visible)
            ctx.shadowBlur = glowSize * 0.5;
            ctx.shadowColor = '#ffffff';
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(p.text, 0, 0);
            
            // Colored accent overlay
            ctx.shadowBlur = 0;
            ctx.globalAlpha = alpha * 0.4;
            ctx.fillStyle = p.color;
            ctx.fillText(p.text, 0, 0);
            
            ctx.restore();
        }
        ctx.restore();
    }
    
    function updateVoxels(t, dt) {
        const celliTime = t - introCfg.loomworksEnd;
        if (celliTime < 0) return;
        
        voxels.forEach(voxel => {
            const data = voxel.userData;
            
            // Skip glitched voxels - they're permanently disabled
            if (data.glitched) return;
            
            const localTime = celliTime - data.dropDelay;
            
            if (localTime < 0) return;
            
            voxel.visible = true;
            
            if (!data.settled) {
                // Dropping phase
                const targetY = data.targetY;
                if (voxel.position.y > targetY) {
                    voxel.position.y -= data.dropSpeed;
                    voxel.material.opacity = Math.min(0.8, voxel.material.opacity + 0.05);
                    data.edges.material.opacity = Math.min(0.6, data.edges.material.opacity + 0.04);
                } else {
                    // Hit the ground, settle
                    voxel.position.y = targetY;
                    data.settled = true;
                    data.settleTime = celliTime;
                    // Play chime sound on landing
                    playVoxelChime();
                }
            } else {
                const settleAge = celliTime - data.settleTime;

                const jiggleFactor = Math.max(0, 1 - settleAge * 0.5);
                data.jigglePhase += dt * 20;
                const jiggleX = Math.sin(data.jigglePhase) * 0.003 * jiggleFactor;
                const jiggleY = Math.cos(data.jigglePhase * 1.3) * 0.002 * jiggleFactor;

                let posX = data.targetX + jiggleX;
                let posY = data.targetY + jiggleY;

                const scaleBounce = settleAge < 0.3 ? 1.0 + (1.0 - settleAge / 0.3) * 0.15 : 1.0;
                let scaleValue = data.baseScale * scaleBounce;

                data.flickerPhase += dt * 8;
                const brightProgress = Math.min(1, settleAge * 0.25);
                let opacityTarget = THREE.MathUtils.lerp(0.1, 0.8, brightProgress) + Math.sin(data.flickerPhase) * 0.15;
                let edgeOpacity = THREE.MathUtils.lerp(0.4, 0.3, brightProgress);
                let baseColor = THREE.MathUtils.lerp(0.2, 1.0, brightProgress);

                let pulseTime = 0;
                let reactionActive = false;

                if (celliBackspaceSequenceStarted && t >= celliBackspaceSequenceTime) {
                    reactionActive = true;
                    const reactionElapsed = t - celliBackspaceSequenceTime;
                    const vibrateDuration = 1.1;
                    if (reactionElapsed < vibrateDuration) {
                        const intensity = THREE.MathUtils.lerp(0.08, 0.0, reactionElapsed / vibrateDuration);
                        posX += (Math.random() - 0.5) * intensity;
                        posY += (Math.random() - 0.5) * intensity;
                        opacityTarget = Math.min(1, opacityTarget + 0.2);
                        edgeOpacity = Math.min(0.85, edgeOpacity + 0.25);
                        baseColor = Math.min(1.0, baseColor + 0.2);
                    } else {
                        pulseTime = reactionElapsed - vibrateDuration;
                        if (!data.backspaceTransformed) {
                            data.backspaceTransformed = true;
                            voxel.geometry = roundedVoxelGeo.clone();
                            const newMat = cellShadeBaseMaterial.clone();
                            voxel.material.dispose();
                            voxel.material = newMat;
                            if (data.edges) {
                                voxel.remove(data.edges);
                            }
                            const newEdges = new THREE.LineSegments(roundedEdgesGeo, cellShadeEdgeMaterial.clone());
                            voxel.add(newEdges);
                            data.edges = newEdges;
                        }
                        const pulse = 1 + 0.08 * Math.sin(pulseTime * 4 + data.backspacePulseOffset);
                        scaleValue = data.baseScale * pulse;
                        opacityTarget = 0.88 + 0.08 * Math.sin(pulseTime * 3 + data.backspacePulseOffset);
                        edgeOpacity = 0.78 + 0.12 * Math.sin(pulseTime * 5 + data.backspacePulseOffset);
                        posX += Math.sin(pulseTime * 2 + data.backspacePulseOffset) * 0.008;
                        posY += Math.cos(pulseTime * 2.2 + data.backspacePulseOffset) * 0.008;
                        baseColor = 1.0;
                    }
                }

                // Only set default position/scale if not in snap animation
                if (!snapTogetherStarted || !data.backspaceTransformed) {
                    voxel.position.x = posX;
                    voxel.position.y = posY;
                    voxel.scale.set(scaleValue, scaleValue, scaleValue);
                }

                if (voxel.material) {
                    if (data.backspaceTransformed) {
                        // If VisiCalc green transition has started, skip all other color logic
                        if (visiCalcGreenTransitionStarted) {
                            // VisiCalc green color is handled in snap-together animation below
                            // Don't override it here
                        } else if (endColorTransitionStart > 0) {
                            // Handle END sequence color transitions
                            const colors = {
                                yellow: { r: 1.0, g: 0.95, b: 0.3 },
                                magenta: { r: 0.95, g: 0.2, b: 0.4 },
                                cyan: { r: 0.2, g: 0.7, b: 0.95 },
                                green: { r: 0.3, g: 0.9, b: 0.4 }
                            };
                            
                            const transitionDuration = 0.6; // 600ms
                            const elapsed = t - endColorTransitionStart;
                            const progress = THREE.MathUtils.clamp(elapsed / transitionDuration, 0, 1);
                            
                            const fromColor = colors[endColorPrevState];
                            const toColor = colors[endColorState];
                            
                            const r = THREE.MathUtils.lerp(fromColor.r, toColor.r, progress);
                            const g = THREE.MathUtils.lerp(fromColor.g, toColor.g, progress);
                            const b = THREE.MathUtils.lerp(fromColor.b, toColor.b, progress);
                            
                            // Static color for green (pixel art style), pulse for others
                            if (endColorState === 'green' && progress >= 1) {
                                voxel.material.color.setRGB(0.3, 0.9, 0.4);
                                voxel.material.opacity = 0.95;
                            } else if (progress >= 1) {
                                // Transition complete - show final color with pulse
                                const pulse = Math.sin(t * 2 + data.backspacePulseOffset) * 0.05;
                                voxel.material.color.setRGB(toColor.r, toColor.g, toColor.b);
                                voxel.material.opacity = 0.9 + pulse;
                            } else {
                                // Mid-transition
                                const pulse = Math.sin(t * 2 + data.backspacePulseOffset) * 0.05;
                                voxel.material.color.setRGB(r, g, b);
                                voxel.material.opacity = 0.9 + pulse;
                            }
                        } else {
                            // Yellow glowing pulse for initial yellow state
                            const yellowPulse = Math.sin(t * 2 + data.backspacePulseOffset);
                            voxel.material.opacity = 0.9 + 0.05 * yellowPulse;
                            const yellowB = 0.3 + 0.1 * yellowPulse;
                            voxel.material.color.setRGB(1.0, 0.95, yellowB);
                        }
                    } else {
                        voxel.material.opacity = opacityTarget;
                        voxel.material.color.setRGB(baseColor, baseColor, baseColor);
                    }
                }

                if (data.edges && data.edges.material) {
                    if (data.backspaceTransformed) {
                        // Handle snap-together: fade out edges DURING green transition
                        if (snapTogetherStarted) {
                            const snapElapsed = t - snapTogetherTime;
                            const vibrateDuration = 0.4;
                            const jiggleDuration = 0.5;
                            const greenTransitionDuration = 0.3;
                            
                            // Fade out edges during green transition
                            if (snapElapsed >= vibrateDuration + jiggleDuration) {
                                // Green transition has started or finished - no edges
                                data.edges.material.opacity = 0;
                                data.edges.visible = false;
                            } else if (snapElapsed >= vibrateDuration) {
                                // During jiggle - start fading
                                const fadeProgress = (snapElapsed - vibrateDuration) / jiggleDuration;
                                data.edges.material.opacity = THREE.MathUtils.lerp(0.6, 0, fadeProgress);
                            }
                        } else {
                            // Edge colors based on END state
                            if (endColorState === 'magenta') {
                                data.edges.material.color.setRGB(1.0, 0.3, 0.5);
                                data.edges.material.opacity = 0.6;
                            } else if (endColorState === 'cyan') {
                                data.edges.material.color.setRGB(0.3, 0.8, 1.0);
                                data.edges.material.opacity = 0.6;
                            } else if (endColorState === 'green') {
                                data.edges.material.color.setRGB(0.4, 1.0, 0.5);
                                data.edges.material.opacity = 0.6;
                            } else {
                                // Yellow edges
                                data.edges.material.color.setRGB(1.0, 0.9, 0.4);
                                data.edges.material.opacity = 0.6 + 0.1 * Math.sin(t * 2.5 + data.backspacePulseOffset);
                            }
                        }
                    } else {
                        data.edges.material.opacity = THREE.MathUtils.clamp(edgeOpacity, 0, 1);
                    }
                }
                
                // Snap-together animation: vibration, then jiggle, then turn green
                if (snapTogetherStarted && data.backspaceTransformed) {
                    // Initialize snap time on first frame
                    if (snapTogetherTime === 0) {
                        snapTogetherTime = t;
                        console.log('⏱️ Snap animation started at t =', t);
                    }
                    
                    const snapElapsed = t - snapTogetherTime;
                    const vibrateDuration = 0.4;
                    const jiggleDuration = 0.5;
                    const greenTransitionDuration = 0.3;
                    const flatHoldDuration = 0.4; // Hold as flat pixels before shrinking
                    
                    
                    if (snapElapsed < vibrateDuration) {
                        // High-frequency vibration
                        const vibrateIntensity = 0.015 * (1 - snapElapsed / vibrateDuration);
                        posX += (Math.random() - 0.5) * vibrateIntensity;
                        posY += (Math.random() - 0.5) * vibrateIntensity;
                        voxel.position.x = posX;
                        voxel.position.y = posY;
                    } else if (snapElapsed < vibrateDuration + jiggleDuration) {
                        // Snap closer + jiggle
                        const jiggleProgress = (snapElapsed - vibrateDuration) / jiggleDuration;
                        const jiggleIntensity = 0.008 * (1 - jiggleProgress);
                        
                        // Pull voxels toward their letter center
                        const targetCenterX = data.targetX;
                        const snapAmount = jiggleProgress * 0.3;
                        posX = THREE.MathUtils.lerp(posX, targetCenterX, snapAmount * 0.1);
                        posX += Math.sin(t * 15 + data.backspacePulseOffset) * jiggleIntensity;
                        posY += Math.cos(t * 18 + data.backspacePulseOffset) * jiggleIntensity;
                        
                        voxel.position.x = posX;
                        voxel.position.y = posY;
                    } else if (snapElapsed < vibrateDuration + jiggleDuration + greenTransitionDuration) {
                        // Transition to VisiCalc green - turn off bloom immediately
                        if (!visiCalcGreenTransitionStarted) {
                            visiCalcGreenTransitionStarted = true;
                            bloomPass.strength = 0.0; // Immediately turn off bloom
                            console.log('💚 Green transition started - bloom OFF, edges should be INVISIBLE');
                            
                            // REMOVE all edges from scene permanently
                            voxels.forEach(v => {
                                if (v.userData.edges) {
                                    v.remove(v.userData.edges);
                                    v.userData.edges.geometry.dispose();
                                    v.userData.edges.material.dispose();
                                    v.userData.edges = null;
                                }
                            });
                            console.log('🗑️ ALL EDGES REMOVED FROM SCENE');
                        }
                        
                        const greenProgress = (snapElapsed - vibrateDuration - jiggleDuration) / greenTransitionDuration;
                        const greenColor = { r: 0.0, g: 1.0, b: 0.0 }; // Pure VisiCalc green
                        
                        // Get current color
                        const currentColor = voxel.material.color;
                        const r = THREE.MathUtils.lerp(currentColor.r, greenColor.r, greenProgress);
                        const g = THREE.MathUtils.lerp(currentColor.g, greenColor.g, greenProgress);
                        const b = THREE.MathUtils.lerp(currentColor.b, greenColor.b, greenProgress);
                        
                        voxel.material.color.setRGB(r, g, b);
                        voxel.material.opacity = 1.0; // Solid for pixel art
                        
                        // Keep bloom off
                        bloomPass.strength = 0.0;
                        
                        // Collapse into tighter mono-spaced grid
                        const monoSpacing = 0.022; // Tight pixel spacing
                        const monoX = data.gridCol * monoSpacing;
                        const monoY = -data.gridRow * monoSpacing;
                        const letterOffsetX = data.letterIdx * 5 * monoSpacing; // 5 columns per letter
                        
                        posX = THREE.MathUtils.lerp(data.targetX, letterOffsetX + monoX, greenProgress);
                        posY = THREE.MathUtils.lerp(data.targetY, monoY, greenProgress);
                        
                        voxel.position.x = posX;
                        voxel.position.y = posY;
                        voxel.scale.set(data.baseScale * 0.95, data.baseScale * 0.95, data.baseScale * 0.95);
                    } else if (snapElapsed < vibrateDuration + jiggleDuration + greenTransitionDuration + flatHoldDuration) {
                        // Hold as flat green pixels in mono-spaced positions
                        bloomPass.strength = 0.0;
                        voxel.material.color.setRGB(0.0, 1.0, 0.0);
                        voxel.material.opacity = 1.0;
                        
                        // Hold at mono-spaced positions
                        const monoSpacing = 0.022;
                        const monoX = data.gridCol * monoSpacing;
                        const monoY = -data.gridRow * monoSpacing;
                        const letterOffsetX = data.letterIdx * 5 * monoSpacing;
                        
                        voxel.position.x = letterOffsetX + monoX;
                        voxel.position.y = monoY;
                        voxel.scale.set(data.baseScale * 0.95, data.baseScale * 0.95, data.baseScale * 0.95);
                    } else {
                        // After flat hold, start move to corner
                        if (!celliMoveToCornerStarted) {
                            celliMoveToCornerStarted = true;
                            celliMoveToCornerTime = t;
                            bloomPass.strength = 0.0;
                            console.log('🎯 Move to corner started at t =', t);
                        }
                    }
                    
                    // Move CELLI to corner animation (runs after flat hold)
                    if (celliMoveToCornerStarted) {
                        const moveElapsed = t - celliMoveToCornerTime;
                        const collapseDuration = 0.6; // Collapse to center
                        const expandDuration = 0.8;   // Expand into VisiCell position
                        const totalMoveDuration = collapseDuration + expandDuration;
                        
                        // Keep bloom off for flat pixel look
                        bloomPass.strength = 0.0;
                        
                        // Keep VisiCalc green color during movement - flat, no glow
                        voxel.material.color.setRGB(0.0, 1.0, 0.0);
                        voxel.material.opacity = 1.0;
                        
                        // Store mono-spaced starting position if not set
                        if (!data.monoStartX) {
                            const monoSpacing = 0.022;
                            const monoX = data.gridCol * monoSpacing;
                            const monoY = -data.gridRow * monoSpacing;
                            const letterOffsetX = data.letterIdx * 5 * monoSpacing;
                            data.monoStartX = letterOffsetX + monoX;
                            data.monoStartY = monoY;
                        }
                        
                        if (moveElapsed < collapseDuration) {
                            // Phase 1: Organic collapse to center with wave motion
                            const collapseProgress = moveElapsed / collapseDuration;
                            const collapseEased = collapseProgress * collapseProgress * (3 - 2 * collapseProgress);
                            
                            // Add wave motion based on voxel index for organic feel
                            const waveOffset = (data.letterIdx * 10 + data.gridRow * 3 + data.gridCol) * 0.05;
                            const waveDelay = Math.max(0, collapseProgress - waveOffset);
                            const waveEased = Math.min(1, waveDelay * 1.3);
                            const waveSine = Math.sin(waveEased * Math.PI);
                            
                            posX = THREE.MathUtils.lerp(data.monoStartX, 0, waveEased);
                            posY = THREE.MathUtils.lerp(data.monoStartY, 0, waveEased);
                            
                            // Add slight orbital motion during collapse
                            const orbitAngle = waveEased * Math.PI * 2;
                            posX += Math.cos(orbitAngle) * (1 - waveEased) * 0.015;
                            posY += Math.sin(orbitAngle) * (1 - waveEased) * 0.015;
                            
                            voxel.position.x = posX;
                            voxel.position.y = posY;
                            
                            // Shrink with pulse
                            const pulse = waveSine * 0.15;
                            const currentScale = THREE.MathUtils.lerp(data.baseScale * 0.95, data.baseScale * 0.3, waveEased) * (1 + pulse);
                            voxel.scale.set(currentScale, currentScale, currentScale);
                            
                            // Keep fully visible during collapse
                            voxel.material.opacity = 1.0;
                        } else if (moveElapsed < totalMoveDuration) {
                            // Phase 2: Expand into VisiCell position
                            const expandProgress = (moveElapsed - collapseDuration) / expandDuration;
                            const expandEased = expandProgress < 0.5 ? 
                                2 * expandProgress * expandProgress : 
                                1 - Math.pow(-2 * expandProgress + 2, 2) / 2;
                            
                            // Target position: top-left corner (where "A1: CELLI" appears)
                            const targetX = -0.85;
                            const targetY = 0.75;
                            const targetScale = 0.45; // Smaller for VisiCell text
                            
                            // Calculate target offset based on grid position
                            const visiCellSpacing = 0.018; // Tighter for VisiCell
                            const targetOffsetX = data.gridCol * visiCellSpacing;
                            const targetOffsetY = -data.gridRow * visiCellSpacing;
                            const targetLetterOffset = data.letterIdx * 5 * visiCellSpacing;
                            
                            posX = THREE.MathUtils.lerp(0, targetX + targetLetterOffset + targetOffsetX, expandEased);
                            posY = THREE.MathUtils.lerp(0, targetY + targetOffsetY, expandEased);
                            
                            voxel.position.x = posX;
                            voxel.position.y = posY;
                            
                            // Expand from collapsed size to target size
                            const currentScale = THREE.MathUtils.lerp(data.baseScale * 0.3, data.baseScale * targetScale, expandEased);
                            voxel.scale.set(currentScale, currentScale, currentScale);
                        } else {
                            // Hold at final VisiCell position
                            const targetX = -0.85;
                            const targetY = 0.75;
                            const targetScale = 0.45;
                            const visiCellSpacing = 0.018;
                            const targetOffsetX = data.gridCol * visiCellSpacing;
                            const targetOffsetY = -data.gridRow * visiCellSpacing;
                            const targetLetterOffset = data.letterIdx * 5 * visiCellSpacing;
                            
                            voxel.position.x = targetX + targetLetterOffset + targetOffsetX;
                            voxel.position.y = targetY + targetOffsetY;
                            voxel.scale.set(data.baseScale * targetScale, data.baseScale * targetScale, data.baseScale * targetScale);
                            
                            // Show VisiCell once animation is complete (only trigger once)
                            if (!visiCalcShown) {
                                visiCalcShown = true;
                                console.log('✅ Move-to-corner animation complete, showing VisiCell');
                                showVisiCalc();
                            }
                        }
                    }
                }
            }
        });

        if (!bowHasTriggered) {
            const allSettled = voxels.every(voxel => voxel.userData && voxel.userData.settled);
            if (allSettled) {
                animateSkipToBow();
            }
        }
    }

    // Restore one voxel from the glitched stack with fritz effect
    function restoreOneLetter() {
        if (restoredLetters >= lettersToRestore.length) return false;
        
        const letterKey = lettersToRestore[restoredLetters];
        const letterVoxelsList = letterVoxels[letterKey];
        
        if (!letterVoxelsList || letterVoxelsList.length === 0) return false;
        
        // Play electrical fritz sound
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        
        // Bigger fritz sound for whole letter
        const buzz = audioCtx.createOscillator();
        const buzzGain = audioCtx.createGain();
        
        buzz.type = 'sawtooth';
        buzz.frequency.setValueAtTime(150, now);
        buzz.frequency.exponentialRampToValueAtTime(100, now + 0.25);
        
        buzzGain.gain.setValueAtTime(0, now);
        buzzGain.gain.linearRampToValueAtTime(0.1, now + 0.02);
        buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
        
        buzz.connect(buzzGain);
        buzzGain.connect(audioCtx.destination);
        buzz.start(now);
        buzz.stop(now + 0.25);
        
        // Restore all voxels in this letter with staggered timing
        letterVoxelsList.forEach((voxel, idx) => {
            const data = voxel.userData;
            const delay = idx * 30; // Stagger by 30ms per voxel
            
            setTimeout(() => {
                // Make visible again
                voxel.visible = true;
                data.edges.visible = true;
                data.glitched = false;
                
                // Start with dark gray
                voxel.material.color.setRGB(0.15, 0.15, 0.15);
                data.edges.material.color.setRGB(0.2, 0.2, 0.2);
                voxel.material.opacity = 0.2;
                data.edges.material.opacity = 0.1;
                
                // Fritz flicker effect
                let flickerCount = 0;
                const maxFlickers = 6;
                const flickerInterval = setInterval(() => {
                    flickerCount++;
                    const flickerOn = flickerCount % 2 === 1;
                    
                    if (flickerOn) {
                        voxel.material.color.setRGB(0.9, 0.9, 0.9);
                        voxel.material.opacity = 0.85;
                        data.edges.material.opacity = 0.6;
                    } else {
                        voxel.material.color.setRGB(0.3, 0.3, 0.3);
                        voxel.material.opacity = 0.3;
                        data.edges.material.opacity = 0.2;
                    }
                    
                    if (flickerCount >= maxFlickers) {
                        clearInterval(flickerInterval);
                        
                        // Restore to normal white/bright state
                        const restoreStart = Date.now();
                        const restoreDuration = 200;
                        const restoreInterval = setInterval(() => {
                            const restoreProgress = (Date.now() - restoreStart) / restoreDuration;
                            if (restoreProgress >= 1) {
                                clearInterval(restoreInterval);
                                voxel.material.color.setRGB(0.8, 0.8, 0.8);
                                voxel.material.opacity = 0.75;
                                data.edges.material.opacity = 0.35;
                            } else {
                                const brightness = THREE.MathUtils.lerp(0.3, 0.8, restoreProgress);
                                voxel.material.color.setRGB(brightness, brightness, brightness);
                                voxel.material.opacity = THREE.MathUtils.lerp(0.3, 0.75, restoreProgress);
                                data.edges.material.opacity = THREE.MathUtils.lerp(0.2, 0.35, restoreProgress);
                            }
                        }, 16);
                    }
                }, 70);
            }, delay);
        });
        
        restoredLetters++;
        
        // If all 4 letters restored (C, E, L, L), automatically restore I and transform
        if (restoredLetters === 4) {
            setTimeout(() => {
                restoreIAndTransform();
            }, 800);
        }
        
        return true;
    }
    
    function restoreIAndTransform() {
        const iVoxels = letterVoxels.I;
        
        // Play final restoration sound
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        
        const buzz = audioCtx.createOscillator();
        const buzzGain = audioCtx.createGain();
        
        buzz.type = 'sine';
        buzz.frequency.setValueAtTime(200, now);
        buzz.frequency.exponentialRampToValueAtTime(400, now + 0.4);
        
        buzzGain.gain.setValueAtTime(0, now);
        buzzGain.gain.linearRampToValueAtTime(0.12, now + 0.05);
        buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        
        buzz.connect(buzzGain);
        buzzGain.connect(audioCtx.destination);
        buzz.start(now);
        buzz.stop(now + 0.4);
        
        // Restore I voxels quickly
        iVoxels.forEach((voxel, idx) => {
            const data = voxel.userData;
            const delay = idx * 20;
            
            setTimeout(() => {
                voxel.visible = true;
                data.edges.visible = true;
                data.glitched = false;
                voxel.material.color.setRGB(0.8, 0.8, 0.8);
                voxel.material.opacity = 0.75;
                data.edges.material.opacity = 0.35;
            }, delay);
        });
        
        // After brief pause, transform all CELLI to yellow rounded glow
        setTimeout(() => {
            transformCelliToYellow();
        }, 600);
    }
    
    function transformCelliToYellow() {
        // Transform all voxels to yellow with rounded corners, pop shrink/burst animation
        const skipBtn = document.getElementById('skipBtn');
        if (skipBtn) {
            skipBtn.classList.add('illuminating');
        }

        yellowTransformCompleteCount = 0;
        allYellowTransformed = false;
        const totalVoxels = voxels.length || 1;

        voxels.forEach((voxel, idx) => {
            const data = voxel.userData;
            const delay = idx * 15; // Stagger transformation
            
            setTimeout(() => {
                // Phase 1: Shrink inward (pop preparation)
                const shrinkStart = Date.now();
                const shrinkDuration = 150;
                
                const shrinkInterval = setInterval(() => {
                    const progress = (Date.now() - shrinkStart) / shrinkDuration;
                    if (progress >= 1) {
                        clearInterval(shrinkInterval);
                        
                        // Phase 2: Burst outward + transform to rounded + yellow color
                        const burstStart = Date.now();
                        const burstDuration = 300;
                        
                        // Change to rounded geometry
                        voxel.geometry.dispose();
                        voxel.geometry = roundedVoxelGeo.clone();
                        voxel.remove(data.edges);
                        const newEdges = new THREE.LineSegments(roundedEdgesGeo, edgeMat.clone());
                        voxel.add(newEdges);
                        data.edges = newEdges;
                        
                        const burstInterval = setInterval(() => {
                            const burstProgress = (Date.now() - burstStart) / burstDuration;
                            if (burstProgress >= 1) {
                                clearInterval(burstInterval);
                                
                                // Phase 3: Settle to yellow
                                voxel.scale.set(data.baseScale, data.baseScale, data.baseScale);
                                voxel.material.color.setRGB(1.0, 0.95, 0.3);
                                voxel.material.opacity = 0.9;
                                data.edges.material.color.setRGB(1.0, 0.9, 0.4);
                                data.edges.material.opacity = 0.6;
                                if (!data.backspaceTransformed) {
                                    data.backspaceTransformed = true;
                                    yellowTransformCompleteCount++;
                                    if (yellowTransformCompleteCount >= totalVoxels) {
                                        allYellowTransformed = true;
                                        activateRoundedBow();
                                    }
                                }
                            } else {
                                // Burst scale and color change
                                const scale = data.baseScale * THREE.MathUtils.lerp(0.5, 1.15, burstProgress);
                                voxel.scale.set(scale, scale, scale);
                                
                                const r = THREE.MathUtils.lerp(0.8, 1.0, burstProgress);
                                const g = THREE.MathUtils.lerp(0.8, 0.95, burstProgress);
                                const b = THREE.MathUtils.lerp(0.8, 0.3, burstProgress);
                                voxel.material.color.setRGB(r, g, b);
                                data.edges.material.color.setRGB(
                                    THREE.MathUtils.lerp(0.8, 1.0, burstProgress),
                                    THREE.MathUtils.lerp(0.8, 0.9, burstProgress),
                                    0.4
                                );
                            }
                        }, 16);
                    } else {
                        // Shrink scale
                        const scale = data.baseScale * THREE.MathUtils.lerp(1.0, 0.5, progress);
                        voxel.scale.set(scale, scale, scale);
                    }
                }, 16);
            }, delay);
        });
    }

    function activateRoundedBow() {
        const skipBtn = document.getElementById('skipBtn');
        if (!skipBtn) return;

        if (!skipBtn.classList.contains('bow-shape')) {
            pendingRoundedBow = true;
            return;
        }

        skipBtn.classList.add('rounded-bow');
        pendingRoundedBow = false;
    }

    // Transform voxels to magenta-red (E input)
    function transformToMagentaRed() {
        endColorPrevState = endColorState;
        endColorState = 'magenta';
        endColorTransitionStart = totalTime;
    }
    
    // Transform voxels to cyan-blue (N input)
    function transformToCyanBlue() {
        endColorPrevState = endColorState;
        endColorState = 'cyan';
        endColorTransitionStart = totalTime;
    }
    
    // Transform voxels to green and snap back to non-rounded (D input)
    function transformToGreenAndSquare() {
        console.log('🟢 transformToGreenAndSquare called');
        endColorPrevState = endColorState;
        endColorState = 'green';
        endColorTransitionStart = totalTime;
        
        // Change back to square geometry immediately
        voxels.forEach((voxel, idx) => {
            const data = voxel.userData;
            if (!data.backspaceTransformed) return;
            
            setTimeout(() => {
                voxel.geometry.dispose();
                voxel.geometry = voxelGeo.clone();
                voxel.remove(data.edges);
                const newEdges = new THREE.LineSegments(edgesGeo, edgeMat.clone());
                voxel.add(newEdges);
                data.edges = newEdges;
            }, idx * 8);
        });
        
        // Start snap-together animation immediately (color transition happens simultaneously)
        snapTogetherStarted = true;
        console.log('🟢 snapTogetherStarted set to true');
        
        // VisiCell will be shown after animation completes (triggered in updateVoxels)
        // snapTogetherTime will be set on first frame in updateVoxels
    }
    
    function computeBowAnchorScreenPosition() {
        const cVoxels = letterVoxels.C || [];
        if (!cVoxels.length) return null;

        let minX = Infinity;
        let maxY = -Infinity;

        cVoxels.forEach((voxel) => {
            const data = voxel.userData;
            if (!data) return;
            minX = Math.min(minX, data.targetX);
            maxY = Math.max(maxY, data.targetY);
        });

        if (!Number.isFinite(minX) || !Number.isFinite(maxY)) {
            return null;
        }

        const anchor = new THREE.Vector3(
            minX - voxelSize * 0.9,
            maxY + voxelSize * 1.4,
            0
        );
        anchor.project(camera);

        return {
            x: (anchor.x + 1) / 2 * window.innerWidth,
            y: (-anchor.y + 1) / 2 * window.innerHeight
        };
    }

    function moveBowToTarget(immediate = false) {
        const skipBtn = document.getElementById('skipBtn');
        if (!skipBtn) return;

        const target = computeBowAnchorScreenPosition();
        if (!target) return;

        bowTargetCenter = target;

        if (!bowCurrentCenter) {
            const rect = skipBtn.getBoundingClientRect();
            bowCurrentCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        if (immediate) {
            bowCurrentCenter = { ...bowTargetCenter };
            skipBtn.style.position = 'fixed';
            skipBtn.style.left = `${bowTargetCenter.x}px`;
            skipBtn.style.top = `${bowTargetCenter.y}px`;
            skipBtn.style.bottom = 'auto';
            skipBtn.style.transform = 'translate(-50%, -50%) scale(1)';
            return;
        }

        const start = { ...bowCurrentCenter };
        const duration = 1200;
        const startTime = performance.now();
        if (bowAnimationId) cancelAnimationFrame(bowAnimationId);

        function step(now) {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);
            const arcHeight = Math.min(window.innerHeight * 0.08, 70);
            const arc = Math.sin(progress * Math.PI) * arcHeight;

            const x = start.x + (bowTargetCenter.x - start.x) * eased;
            const y = start.y + (bowTargetCenter.y - start.y) * eased - arc;

            bowCurrentCenter = { x, y };
            skipBtn.style.position = 'fixed';
            skipBtn.style.left = `${x}px`;
            skipBtn.style.top = `${y}px`;
            skipBtn.style.bottom = 'auto';
            const scale = 1 + 0.12 * (1 - eased);
            skipBtn.style.transform = `translate(-50%, -50%) scale(${scale})`;

            if (progress < 1) {
                bowAnimationId = requestAnimationFrame(step);
            } else {
                bowAnimationId = 0;
                bowCurrentCenter = { ...bowTargetCenter };
                skipBtn.style.transform = 'translate(-50%, -50%) scale(1)';
                bowActive = true;
            }
        }

        bowAnimationId = requestAnimationFrame(step);
    }

    // Animate skip triangles to form a bow above CELLI
    function animateSkipToBow({ immediate = false } = {}) {
        const skipBtn = document.getElementById('skipBtn');
        const tri1 = document.getElementById('skipTriangle1');
        const tri2 = document.getElementById('skipTriangle2');

        if (!skipBtn || !tri1 || !tri2) return;

        if (!immediate) {
            if (bowHasTriggered) return;
            bowHasTriggered = true;
        }

        skipBtn.classList.remove('hidden');
        tri1.style.transform = '';
        tri2.style.transform = '';
        skipBtn.classList.add('bow-lock');
        skipBtn.classList.add('bow-shape');

        if (pendingRoundedBow) {
            skipBtn.classList.add('rounded-bow');
            pendingRoundedBow = false;
        }

        bowActive = false;
        bowCurrentCenter = null;
        moveBowToTarget(immediate);
    }
    
    // Show VisiCell spreadsheet
    function showVisiCalc() {
        console.log('📺 showVisiCalc called!');
        // Fade out doorway
        const doorway = document.getElementById('doorway');
        if (doorway) {
            doorway.style.transition = 'opacity 0.5s ease';
            doorway.style.opacity = '0';
            console.log('📺 Doorway faded out');
        }
        
        // Create VisiCell overlay (appears behind 3D scene initially)
        const visiCalc = document.createElement('div');
        visiCalc.id = 'visicalc';
        visiCalc.style.cssText = `
            position: fixed;
            inset: 0;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 20px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.8s ease;
            overflow: hidden;
        `;
        
        // Create VisiCell content (without CELLI in row 1 - the 3D pixels will be that)
        visiCalc.innerHTML = `
            <div style="border: 2px solid #0f0; padding: 10px; height: calc(100% - 40px); background: #000; opacity: 0; transition: opacity 0.6s ease;" id="visicalc-frame">
                <div style="border-bottom: 1px solid #0f0; padding-bottom: 5px; margin-bottom: 10px; opacity: 0; animation: fadeInVisi 0.4s ease forwards 0.2s; font-size: 13px; font-family: 'Courier New', monospace;">
                    <span style="float: left;">VISICELL</span>
                    <span style="float: right;">LOOMWORKS CELL</span>
                    <div style="clear: both;"></div>
                </div>
                <div style="font-family: 'Courier New', monospace; white-space: pre; line-height: 1.6; font-size: 13px; opacity: 0; animation: fadeInVisi 0.5s ease forwards 0.5s;">
>A1:
     A            B            C            D            E            F
1
2
3    LOOK
4
5    END
6
7    =STAR                     =T
8
9
10
11
12
13
14
15   =TRANSPOSE()
16
17
18
19
 20   LOOMWORKS
 21
 22
 23   <span class="visicell-note-line visicell-note-line--1">&gt;:(</span>
 24   <span class="visicell-note-line visicell-note-line--2">This isn't Stanley Parable. Don't try that again.</span>
                </div>
                <div id="visicellinput" style="position: absolute; top: 24px; right: 36px; left: auto; bottom: auto; border-top: 1px solid #0f0; padding-top: 10px; opacity: 0; animation: fadeInVisi 0.3s ease forwards 1s; cursor: text; font-family: 'Courier New', monospace; font-size: 13px; z-index: 100; pointer-events: auto; text-align: right;">
                    <span id="visicellprompt">ENTE<span style="animation: blink 1s step-end infinite;">_</span></span>
                </div>
            </div>
            <style>
                @keyframes fadeInVisi {
                    from { opacity: 0; transform: translateY(10px); }
                    to { opacity: 1; transform: translateY(0); }
                }
                @keyframes matrixShake {
                    0% { transform: translate(0, 0); }
                    25% { transform: translate(-2px, 2px); }
                    50% { transform: translate(2px, -2px); }
                    75% { transform: translate(-2px, -2px); }
                    100% { transform: translate(2px, 2px); }
                }
            </style>
        `;
        
        document.body.appendChild(visiCalc);
        
        // Snap VisiCell into view immediately
        visiCalc.style.opacity = '1';
        
        const frame = document.getElementById('visicalc-frame');
        if (frame) {
            frame.style.opacity = '1';
        }
        
        // Immediately show all content (override animations)
        const allAnimated = visiCalc.querySelectorAll('[style*="animation"]');
        allAnimated.forEach(el => {
            el.style.opacity = '1';
            el.style.animation = 'none';
        });
        
        // Setup terminal input system immediately
        setTimeout(() => {
            setupTerminalInput();
        }, 100);
        
        // Fade out 3D renderer immediately
        renderer.domElement.style.transition = 'opacity 0.5s ease';
        renderer.domElement.style.opacity = '0';
        
        // Stop rendering 3D scene
        setTimeout(() => {
            running = false;
        }, 500);
    }
    
    let terminalInput = 'ENTE';
    let terminalActive = false;
    let rInfectionStarted = false;
    let rInfectionStage = 0;
    let promptResetting = false;
    let promptClearInterval = null;
    let promptFillInterval = null;
    
    function setupTerminalInput() {
        console.log('⌨️ Terminal input system activated');
        terminalActive = true;
        
        const inputEl = document.getElementById('visicellinput');
        const promptEl = document.getElementById('visicellprompt');
        const visiCalc = document.getElementById('visicalc');
        const frame = document.getElementById('visicalc-frame');
        if (!inputEl || !promptEl) return;
        
        // Clicking anywhere (except input area) triggers R infection
        if (visiCalc) {
            visiCalc.addEventListener('click', (e) => {
                // Don't trigger if clicking on input area
                if (e.target.id === 'visicellinput' || e.target.id === 'visicellprompt' || e.target.closest('#visicellinput')) {
                    return;
                }
                if (terminalActive) {
                    triggerRInfection(frame);
                }
            });
        }
        
        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            if (!terminalActive) return;

            if (promptResetting) {
                cancelPromptReset();
            }

            if (e.key === 'Backspace') {
                e.preventDefault();
                if (terminalInput.length > 0) {
                    terminalInput = terminalInput.slice(0, -1);
                    updateTerminalPrompt();
                    evaluateTerminalInputDrift();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                handleTerminalCommand();
            } else if (e.key.length === 1 && /[a-zA-Z0-9._]/.test(e.key)) {
                e.preventDefault();
                terminalInput += e.key.toUpperCase();
                updateTerminalPrompt();
                evaluateTerminalInputDrift();
            }
        });

        updateTerminalPrompt();
        if (terminalInput !== 'ENTE') {
            schedulePromptToEnte({ immediateFill: true });
        }
    }
    
    function updateTerminalPrompt() {
        const promptEl = document.getElementById('visicellprompt');
        if (!promptEl) return;
        promptEl.innerHTML = terminalInput + '<span style="animation: blink 1s step-end infinite;">_</span>';
    }

    const validTerminalCommands = ['ENTER', 'EXIT', 'LEAVE', 'MYHOUSE.WAD', 'OURHOUSE.LOOM', 'MADNESS.LOOM'];

    function cancelPromptReset() {
        if (promptClearInterval) {
            clearInterval(promptClearInterval);
            promptClearInterval = null;
        }
        if (promptFillInterval) {
            clearInterval(promptFillInterval);
            promptFillInterval = null;
        }
        promptResetting = false;
    }

    function schedulePromptToEnte({ immediateFill = false } = {}) {
        if (!terminalActive) return;

        cancelPromptReset();
        promptResetting = true;

        const target = 'ENTE';

        const startFill = () => {
            let index = 0;
            promptFillInterval = setInterval(() => {
                if (!terminalActive) {
                    cancelPromptReset();
                    return;
                }

                if (index < target.length) {
                    terminalInput += target[index];
                    index++;
                    updateTerminalPrompt();
                } else {
                    cancelPromptReset();
                }
            }, 240);
        };

        if (!immediateFill && terminalInput.length > 0) {
            promptClearInterval = setInterval(() => {
                if (!terminalActive) {
                    cancelPromptReset();
                    return;
                }

                if (terminalInput.length > 0) {
                    terminalInput = terminalInput.slice(0, -1);
                    updateTerminalPrompt();
                } else {
                    clearInterval(promptClearInterval);
                    promptClearInterval = null;
                    startFill();
                }
            }, 260);
        } else {
            terminalInput = '';
            updateTerminalPrompt();
            startFill();
        }
    }

    function isValidTerminalPrefix(value) {
        if (!value) return true;
        return validTerminalCommands.some(cmd => cmd.startsWith(value));
    }

    function evaluateTerminalInputDrift() {
        if (!terminalActive || promptResetting) return;
        const value = terminalInput.toUpperCase();
        if (!value || isValidTerminalPrefix(value)) {
            return;
        }
        schedulePromptToEnte();
    }

    function handleTerminalCommand() {
        const cmd = terminalInput.trim();
        const frame = document.getElementById('visicalc-frame');
        console.log('🖥️ Terminal command:', cmd);
        
        if (cmd === 'ENTER') {
            triggerRInfection(frame);
            terminalInput = '';
            updateTerminalPrompt();
            schedulePromptToEnte({ immediateFill: true });
        } else if (cmd === 'EXIT') {
            triggerExitCube(frame);
            terminalInput = '';
            updateTerminalPrompt();
            schedulePromptToEnte({ immediateFill: true });
        } else if (cmd === 'LEAVE') {
            triggerLeaveSequence(frame);
            terminalInput = '';
            updateTerminalPrompt();
            schedulePromptToEnte({ immediateFill: true });
        } else if (cmd.toLowerCase() === 'myhouse.wad') {
            terminalResponse(frame, '"Too scary. How about OurHouse.loom?"');
        } else if (cmd.toLowerCase() === 'ourhouse.loom') {
            terminalResponse(frame, '"Huh... Not found. I must have renamed it. I asked my friends Crosby, Stills, Nash AND Young, none of them knew. Maybe wrong band."');
        } else if (cmd.toLowerCase() === 'madness.loom') {
            terminalInput = '';
            updateTerminalPrompt();
            schedulePromptToEnte({ immediateFill: true });
            triggerVictory(frame);
        } else {
            terminalResponse(frame, `Command not recognized: ${cmd}`);
        }
    }
    
    function terminalResponse(frame, message) {
        if (!frame) return;
        const responseDiv = document.createElement('div');
        responseDiv.style.cssText = 'margin-top: 10px; color: #0f0; font-family: "Courier New", monospace; font-size: 13px;';
        responseDiv.textContent = message;
        frame.appendChild(responseDiv);

        // Reset input
        terminalInput = '';
        updateTerminalPrompt();
        schedulePromptToEnte({ immediateFill: true });
    }
    
    let rInfectionProcessing = false;
    
    function triggerRInfection(frame) {
        if (!frame) return;
        
        // Prevent rapid clicking from breaking the sequence
        if (rInfectionProcessing) {
            console.log('⏸️ R infection already in progress, ignoring click');
            return;
        }
        
        if (rInfectionStarted) {
            console.log('🔴 R infection already started, ignoring additional clicks');
            return;
        }
        
        rInfectionStarted = true;
        rInfectionProcessing = true;
        rInfectionStage = 1;
        console.log('🔴 R infection stage 1 - infecting existing text');
        
        // Stage 1: Infect existing text characters with Rs
        progressRInfection(frame);
    }
    
    function progressRInfection(frame) {
        console.log('🔴 R infection stage', rInfectionStage);
        
        if (rInfectionStage === 1) {
            // Stage 1: Cascade Rs through existing text (but not input)
            const allText = frame.querySelectorAll('*:not(#rHint):not(#visicellinput):not(#visicellprompt)');
            const textNodes = [];
            allText.forEach(el => {
                // Skip input-related elements
                if (el.id === 'visicellinput' || el.id === 'visicellprompt' || el.closest('#visicellinput')) {
                    return;
                }
                if (el.childNodes.length > 0) {
                    el.childNodes.forEach(node => {
                        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                            textNodes.push(node);
                        }
                    });
                }
            });
            
            const originalTexts = textNodes.map(n => n.textContent);
            const infectionDuration = 2500;
            const infectionStart = Date.now();
            
            const infectionInterval = setInterval(() => {
                const elapsed = Date.now() - infectionStart;
                const progress = elapsed / infectionDuration;
                
                if (progress >= 1) {
                    clearInterval(infectionInterval);
                    // Auto-progress to stage 2 (type ASCII R)
                    setTimeout(() => {
                        rInfectionStage++;
                        progressRInfection(frame);
                    }, 800);
                } else {
                    textNodes.forEach((node, idx) => {
                        const nodeProgress = Math.max(0, progress - (idx * 0.03));
                        if (nodeProgress > 0) {
                            const original = originalTexts[idx];
                            const infected = original.split('').map((c) => {
                                if (c === ' ' || c === '\n') return c;
                                if (Math.random() < nodeProgress * 1.5) return 'R';
                                return c;
                            }).join('');
                            node.textContent = infected;
                        }
                    });
                }
            }, 50);
            
        } else if (rInfectionStage === 2) {
            // Stage 2: From infected text, organically type out ASCII R
            let rHint = document.getElementById('rHint');
            if (!rHint) {
                rHint = document.createElement('div');
                rHint.id = 'rHint';
                rHint.style.cssText = `
                    position: absolute;
                    top: 30%;
                    left: 50%;
                    transform: translateX(-50%);
                    font-family: 'Courier New', monospace;
                    white-space: pre;
                    text-align: left;
                    font-size: 13px;
                    line-height: 1.6;
                    color: #0f0;
                    opacity: 1;
                    pointer-events: none;
                    z-index: 55;
                `;
                rHint.classList.add('r-hint');
                rHint.style.textShadow = 'none';
                frame.appendChild(rHint);
            }
            
            const asciiR = `
RRRRRRRRRRRRRRR
RRRRRRRRRRRRRRR
RRRR       RRRR
RRRR       RRRR
RRRR       RRRR
RRRR       RRRR
RRRRRRRRRRRRRRR
RRRRRRRRRRRRRRR
RRRRRRRRRRR    
RRRR    RRRR   
RRRR      RRRR 
RRRR        RRRR
RRRR          RRRR
RRRR            RRRR`;
            
            // Type out character by character with polished timing
            let charIndex = 0;
            const typeInterval = setInterval(() => {
                if (charIndex < asciiR.length) {
                    rHint.textContent = asciiR.substring(0, charIndex + 1);
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                    setTimeout(() => {
                        rHint.classList.add('glow');
                    }, 200);

                    setTimeout(() => {
                        rInfectionStage++;
                        progressRInfection(frame);
                    }, 1100);
                }
            }, 20); // Smooth, fast typing
            
        } else if (rInfectionStage === 3) {
            // Stage 3: From ASCII R, organically grow matrix data fall
            startMatrixDataFallOrganic(frame);
            
            // Auto-progress to forming R
            setTimeout(() => {
                rInfectionStage++;
                progressRInfection(frame);
            }, 3500);
            
        } else if (rInfectionStage === 4) {
            // Stage 4: Matrix stops and forms large falling R in BLACK (negative space)
            stopMatrixAndFormBlackR(frame, () => {
                rInfectionStage++;
                progressRInfection(frame);
            });

        } else if (rInfectionStage >= 5) {
            // Stage 5: Text-to-speech "R" (are) on loop
            playTextToSpeechR();
        }
    }
    
    function playTextToSpeechR() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // Synthesize "are" sound using oscillators
        function speakR() {
            const now = audioCtx.currentTime;
            const duration = 0.6;
            
            // "Are" has an "ah" vowel transitioning to "r"
            const vowelOsc = audioCtx.createOscillator();
            const vowelGain = audioCtx.createGain();
            const vowelFilter = audioCtx.createBiquadFilter();
            
            // Vowel formants for "ah" -> "r"
            vowelOsc.type = 'sawtooth';
            vowelOsc.frequency.setValueAtTime(120, now); // Base pitch
            
            vowelFilter.type = 'bandpass';
            vowelFilter.frequency.setValueAtTime(700, now); // "ah" formant
            vowelFilter.frequency.linearRampToValueAtTime(500, now + duration); // transition to "r"
            vowelFilter.Q.value = 5;
            
            vowelGain.gain.setValueAtTime(0, now);
            vowelGain.gain.linearRampToValueAtTime(0.15, now + 0.05);
            vowelGain.gain.linearRampToValueAtTime(0.12, now + duration - 0.1);
            vowelGain.gain.linearRampToValueAtTime(0, now + duration);
            
            vowelOsc.connect(vowelFilter);
            vowelFilter.connect(vowelGain);
            vowelGain.connect(audioCtx.destination);
            
            vowelOsc.start(now);
            vowelOsc.stop(now + duration);
        }
        
        // Play immediately and loop every 2 seconds
        speakR();
        setInterval(speakR, 2000);
    }
    
    let matrixInterval = null;
    let matrixColumns = [];
    let matrixOpacity = 0;
    let cascadeInterval = null;
    let matrixSeedCache = null;

    function wrapAsciiRHint(rHint) {
        if (!rHint) return [];
        if (rHint.dataset.wrapped === '1') {
            return Array.from(rHint.querySelectorAll('.r-char'));
        }

        const lines = (rHint.textContent || '').split('\n');
        rHint.innerHTML = '';

        lines.forEach((line, rowIdx) => {
            const rowEl = document.createElement('div');
            rowEl.className = 'r-line';
            [...line].forEach((char, colIdx) => {
                const span = document.createElement('span');
                span.className = 'r-char';
                span.dataset.row = String(rowIdx);
                span.dataset.col = String(colIdx);
                if (char.trim() === '') {
                    span.innerHTML = '&nbsp;';
                    span.dataset.solid = '0';
                } else {
                    span.textContent = char;
                    span.dataset.solid = '1';
                }
                rowEl.appendChild(span);
            });
            rHint.appendChild(rowEl);
        });

        rHint.dataset.wrapped = '1';
        return Array.from(rHint.querySelectorAll('.r-char'));
    }

    function captureMatrixSeeds(frame) {
        const rHint = document.getElementById('rHint');
        if (!rHint) return;

        const spans = wrapAsciiRHint(rHint);
        if (!spans.length) return;

        const frameRect = frame.getBoundingClientRect();
        const seeds = [];

        spans.forEach((span) => {
            if (span.dataset.solid !== '1') return;
            const rect = span.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const normalizedX = (centerX - frameRect.left) / frameRect.width;
            const normalizedY = (centerY - frameRect.top) / frameRect.height;
            seeds.push({
                x: Math.min(0.999, Math.max(0, normalizedX)),
                y: Math.min(0.999, Math.max(0, normalizedY)),
                char: span.textContent && span.textContent.trim() ? span.textContent.trim()[0] : 'R'
            });
        });

        if (seeds.length) {
            matrixSeedCache = {
                seeds,
                capturedAt: performance.now()
            };
        }
    }

    function animateAsciiRDeconstruction(rHint, onComplete) {
        const spans = wrapAsciiRHint(rHint).filter(span => span.dataset.solid === '1');
        if (!spans.length) {
            if (typeof onComplete === 'function') onComplete();
            return 0;
        }

        const delays = [];
        spans.forEach((span) => {
            const row = Number(span.dataset.row || 0);
            const col = Number(span.dataset.col || 0);
            const delay = 220 + row * 90 + col * 25;
            delays.push(delay);

            setTimeout(() => {
                span.classList.add('falling');
            }, delay);

            setTimeout(() => {
                span.innerHTML = '&nbsp;';
                span.dataset.solid = '0';
            }, delay + 620);
        });

        const totalDuration = Math.max(...delays) + 900;
        setTimeout(() => {
            if (rHint) {
                rHint.style.opacity = '0';
            }
        }, Math.max(0, totalDuration - 420));

        setTimeout(() => {
            if (rHint) {
                rHint.style.display = 'none';
            }
            if (typeof onComplete === 'function') {
                onComplete();
            }
        }, totalDuration);

        return totalDuration;
    }

    function cascadeAllCharacters(frame, onComplete) {
        if (!frame) {
            if (typeof onComplete === 'function') onComplete();
            return;
        }

        if (cascadeInterval) {
            clearInterval(cascadeInterval);
            cascadeInterval = null;
        }

        let overlay = document.getElementById('frameCascade');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'frameCascade';
        }

        overlay.style.cssText = 'font-family:"Courier New", monospace; font-size:13px; line-height:1.6; white-space:pre; position:absolute; inset:10px; color:#0f0; text-shadow:0 0 3px #0f0; pointer-events:none; opacity:1; background:transparent;';
        frame.appendChild(overlay);

        const frameRect = frame.getBoundingClientRect();
        const columns = Math.max(1, Math.floor(frameRect.width / 8));
        const rows = Math.max(1, Math.floor(frameRect.height / 21));
        const matrixChars = 'R∅01';
        let step = 0;
        const depth = rows + 18;

        cascadeInterval = setInterval(() => {
            if (!overlay.isConnected) {
                clearInterval(cascadeInterval);
                cascadeInterval = null;
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                return;
            }

            let output = '';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < columns; j++) {
                    const waveOrigin = (j * 3) % depth;
                    const progress = step - waveOrigin;
                    if (progress >= 0 && progress <= rows + 6) {
                        const intensity = Math.min(1, Math.max(0.1, 1 - progress / (rows + 6)));
                        if (Math.random() < 0.25 + intensity * 0.5) {
                            output += matrixChars[Math.floor(Math.random() * matrixChars.length)];
                        } else {
                            output += ' ';
                        }
                    } else {
                        output += ' ';
                    }
                }
                output += '\n';
            }

            overlay.textContent = output;
            step++;

            if (step > depth + rows + 6) {
                clearInterval(cascadeInterval);
                cascadeInterval = null;
                overlay.style.transition = 'opacity 0.6s ease';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                }, 600);

                if (typeof onComplete === 'function') {
                    onComplete();
                }
            }
        }, 70);
    }

    function startMatrixDataFallOrganic(frame, options = {}) {
        const { skipIntro = false, heavyRamp = false } = options;
        const rHint = document.getElementById('rHint');

        if (!skipIntro && rHint && rHint.dataset.deconstructed !== '1') {
            if (rHint.dataset.deconstructed === 'pending') {
                return;
            }

            if (!rHint.classList.contains('glow')) {
                rHint.classList.add('glow');
            }

            captureMatrixSeeds(frame);
            rHint.dataset.deconstructed = 'pending';
            animateAsciiRDeconstruction(rHint, () => {
                rHint.dataset.deconstructed = '1';
                cascadeAllCharacters(frame, () => {
                    startMatrixDataFallOrganic(frame, { skipIntro: true, heavyRamp: true });
                });
            });
            return;
        }

        console.log('🌊 Starting organic matrix data fall');
        const matrixChars = 'R∅01';

        const frameRect = frame.getBoundingClientRect();
        const columns = Math.max(1, Math.floor(frameRect.width / 8));
        const rows = Math.max(1, Math.floor(frameRect.height / 21));

        console.log(`📐 Matrix dimensions: ${columns} cols x ${rows} rows (frame: ${frameRect.width}x${frameRect.height})`);

        const seedsByColumn = Array.from({ length: columns }, () => []);
        if (matrixSeedCache && Array.isArray(matrixSeedCache.seeds)) {
            matrixSeedCache.seeds.forEach(({ x, y, char }) => {
                const col = Math.min(columns - 1, Math.max(0, Math.floor(x * columns)));
                const row = Math.min(rows - 1, Math.max(0, Math.floor(y * rows)));
                seedsByColumn[col].push({ row, char });
            });
            seedsByColumn.forEach((list) => list.sort((a, b) => a.row - b.row));
        }

        let container = document.getElementById('matrixContainer');
        const containerStyles = 'font-family: "Courier New", monospace; font-size: 13px; line-height: 1.6; color: #0f0; text-shadow: 0 0 2px #0f0; white-space: pre; overflow: hidden; width: calc(100% - 20px); height: calc(100% - 20px); position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 50; background: transparent; margin: 0; padding: 0; opacity: 0; transition: opacity 1s ease, background-color 1.5s ease;';
        if (!container) {
            container = document.createElement('div');
            container.id = 'matrixContainer';
            container.style.cssText = containerStyles;
            frame.appendChild(container);
            console.log('✅ Matrix container created (within frame, respecting border)');
        } else {
            container.style.cssText = containerStyles;
            console.log('♻️ Matrix container reset (within frame, respecting border)');
        }

        if (matrixInterval) {
            clearInterval(matrixInterval);
            console.log('🛑 Cleared existing matrix interval');
        }

        matrixOpacity = 0;
        const fadeStart = performance.now();
        const fadeDuration = 900;
        const fadeStep = () => {
            const elapsed = performance.now() - fadeStart;
            const progress = Math.min(elapsed / fadeDuration, 1);
            const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            matrixOpacity = 0.18 + eased * 0.82;
            container.style.opacity = matrixOpacity.toString();
            if (progress < 1) {
                requestAnimationFrame(fadeStep);
            }
        };
        requestAnimationFrame(fadeStep);

        const baseTail = heavyRamp ? 11 : 8;
        const createColumnState = (seedList = [], columnIndex) => {
            const queue = seedList.slice();
            const firstSeed = queue.shift();
            const shimmerPhase = Math.random() * Math.PI * 2;
            if (firstSeed) {
                return {
                    columnIndex,
                    head: firstSeed.row,
                    originalSeedRow: firstSeed.row,
                    velocity: 0.18 + Math.random() * 0.08,
                    maxVelocity: heavyRamp ? 1.55 : 1.05,
                    tail: baseTail + Math.floor(Math.random() * 4),
                    hold: 6 + Math.floor(Math.random() * 6),
                    queue,
                    seededChar: firstSeed.char || 'R',
                    ambient: false,
                    shimmerPhase
                };
            }

            return {
                columnIndex,
                head: -Math.random() * rows * 0.8,
                originalSeedRow: null,
                velocity: 0.55 + Math.random() * 0.3,
                maxVelocity: heavyRamp ? 1.45 : 1.0,
                tail: baseTail - 2 + Math.floor(Math.random() * 4),
                hold: 0,
                queue: [],
                seededChar: null,
                ambient: true,
                shimmerPhase
            };
        };

        matrixColumns = Array.from({ length: columns }, (_, columnIndex) => createColumnState(seedsByColumn[columnIndex], columnIndex));

        const randomMatrixChar = () => matrixChars[Math.floor(Math.random() * matrixChars.length)];

        const columnChar = (state, rowIndex, activationCutoff) => {
            if (!state) return ' ';

            const headPos = state.head;
            const distance = headPos - rowIndex;
            const tailLength = Math.max(1, state.tail);

            if (distance > -0.55 && distance < 0.55) {
                return state.seededChar && state.hold > 0 ? state.seededChar : randomMatrixChar();
            }

            if (distance >= 0.55 && distance <= tailLength + 0.65) {
                const depth = (distance - 0.55) / tailLength;
                const intensity = Math.max(0, 1 - depth);
                const density = heavyRamp ? 0.35 + intensity * 0.55 : 0.22 + intensity * 0.5;
                if (Math.random() < density) {
                    return randomMatrixChar();
                }
            }

            if (state.ambient && activationCutoff > 0.35) {
                const wave = 0.05 * Math.sin(rowIndex * 0.25 + state.shimmerPhase + activationCutoff * Math.PI * 2);
                const ambientBase = heavyRamp ? 0.18 + activationCutoff * 0.45 : 0.08 + activationCutoff * 0.3;
                if (Math.random() < ambientBase + wave) {
                    return randomMatrixChar();
                }
            }

            return ' ';
        };

        let activationProgress = 0;
        const baseActivationSpeed = heavyRamp ? 0.0045 : 0.0075;
        let heavyGlow = heavyRamp ? 0 : 1;

        matrixInterval = setInterval(() => {
            if (heavyRamp) {
                heavyGlow = Math.min(1, heavyGlow + 0.008);
            }

            activationProgress = Math.min(1, activationProgress + baseActivationSpeed + (heavyRamp ? heavyGlow * 0.006 : 0));
            const activationCutoff = heavyRamp ? activationProgress * (0.6 + heavyGlow * 0.4) : activationProgress;

            const lines = [];
            for (let i = 0; i < rows; i++) {
                let line = '';
                for (let j = 0; j < columns; j++) {
                    const columnThreshold = columns <= 1 ? 1 : j / (columns - 1);
                    if (columnThreshold > activationCutoff) {
                        line += ' ';
                        continue;
                    }

                    line += columnChar(matrixColumns[j], i, activationCutoff);
                }
                lines.push(line);
            }
            container.textContent = lines.join('\n');

            matrixColumns.forEach((state, index) => {
                if (!state) return;

                if (state.hold > 0) {
                    state.hold -= 1;
                } else {
                    const acceleration = heavyRamp ? 0.06 + Math.random() * 0.02 : 0.035 + Math.random() * 0.015;
                    state.head += state.velocity;
                    state.velocity = Math.min(state.maxVelocity, state.velocity + acceleration);
                }

                if (!state.ambient && state.seededChar && state.hold <= 0 && state.originalSeedRow !== null && state.head - state.originalSeedRow > state.tail * 0.6) {
                    state.seededChar = null;
                }

                if (state.head - state.tail > rows + 2) {
                    if (state.queue.length) {
                        const nextSeed = state.queue.shift();
                        state.head = nextSeed.row;
                        state.originalSeedRow = nextSeed.row;
                        state.velocity = 0.2 + Math.random() * 0.08;
                        state.maxVelocity = heavyRamp ? 1.55 : 1.05;
                        state.tail = baseTail + Math.floor(Math.random() * 4);
                        state.hold = 4 + Math.floor(Math.random() * 4);
                        state.seededChar = nextSeed.char || 'R';
                        state.ambient = false;
                    } else {
                        state.head = -Math.random() * rows * 0.6;
                        state.originalSeedRow = null;
                        state.velocity = 0.55 + Math.random() * 0.25;
                        state.maxVelocity = heavyRamp ? 1.45 : 1.0;
                        state.tail = baseTail - 2 + Math.floor(Math.random() * 4);
                        state.hold = 0;
                        state.seededChar = null;
                        state.ambient = true;
                    }
                }

                if (state.ambient && activationCutoff < 0.4 && index % 2 === 0) {
                    state.head += 0.2 * Math.sin(activationProgress * Math.PI * 0.5 + state.shimmerPhase);
                }
            });

            if (heavyRamp) {
                const bgAlpha = 0.55 + heavyGlow * 0.4;
                container.style.backgroundColor = `rgba(0, 0, 0, ${bgAlpha.toFixed(2)})`;
            } else if (activationProgress >= 0.6) {
                container.style.backgroundColor = 'rgba(0, 0, 0, 0.88)';
            }
        }, 60);

        console.log('🔄 Organic matrix interval started');
    }
    function stopMatrixAndFormBlackR(frame, onComplete) {
        console.log('🔴 Organically forming BLACK R in negative space');

        const matrixChars = 'R∅01';
        const frameRect = frame.getBoundingClientRect();
        const cols = Math.floor(frameRect.width / 8);
        const rows = Math.floor(frameRect.height / 21);

        const rWidth = 30;
        const rHeight = 19;
        const startCol = Math.floor((cols - rWidth) / 2);
        const startRow = Math.floor((rows - rHeight) / 2);

        console.log(`🎨 R dimensions: ${rWidth}x${rHeight} at col ${startCol}, row ${startRow} (frame: ${cols}x${rows})`);

        const container = document.getElementById('matrixContainer');
        if (container) {
            container.style.backgroundColor = 'rgba(0, 0, 0, 0.98)';
            container.style.opacity = '1';
            container.style.textShadow = '0 0 4px #0f0, 0 0 8px #0f0';

            const rPattern = [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],
            ];

            const isRBase = (row, col) => {
                const relRow = row - startRow;
                const relCol = col - startCol;
                if (relRow >= 0 && relRow < rPattern.length && relCol >= 0 && relCol < rPattern[0].length) {
                    return rPattern[relRow][relCol] === 1;
                }
                return false;
            };

            if (matrixInterval) {
                clearInterval(matrixInterval);
                matrixInterval = null;
            }

            const randomMatrixChar = () => matrixChars[Math.floor(Math.random() * matrixChars.length)];

            let transitionProgress = 0;
            const transitionDuration = 80;

            const formRInterval = setInterval(() => {
                transitionProgress++;
                const progress = Math.min(transitionProgress / transitionDuration, 1);
                const easedProgress = progress < 0.5
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                const lines = [];
                for (let i = 0; i < rows; i++) {
                    let line = '';
                    for (let j = 0; j < cols; j++) {
                        const shouldBeR = isRBase(i, j);
                        const random = Math.random();

                        if (shouldBeR) {
                            const distanceFromCenter = Math.abs(i - startRow - rHeight / 2) + Math.abs(j - startCol - rWidth / 2);
                            const localProgress = Math.max(0, easedProgress - (distanceFromCenter * 0.01));
                            if (random < localProgress || easedProgress > 0.6) {
                                line += randomMatrixChar();
                            } else {
                                line += random < 0.3 ? randomMatrixChar() : ' ';
                            }
                        } else {
                            const distanceFromR = Math.min(
                                Math.abs(i - startRow),
                                Math.abs(i - (startRow + rHeight)),
                                Math.abs(j - startCol),
                                Math.abs(j - (startCol + rWidth))
                            );
                            const clearProgress = Math.min(easedProgress + (distanceFromR * 0.005), 1);

                            if (random > clearProgress) {
                                line += randomMatrixChar();
                            } else {
                                line += ' ';
                            }
                        }
                    }
                    lines.push(line);
                }

                container.textContent = lines.join('\n');

                if (transitionProgress >= transitionDuration) {
                    clearInterval(formRInterval);

                    let animFrame = 0;
                    const shimmerInterval = setInterval(() => {
                        const pulseIntensity = Math.sin(animFrame * 0.1) * 0.3 + 0.7;
                        const shimmerLines = [];
                        for (let i = 0; i < rows; i++) {
                            let line = '';
                            for (let j = 0; j < cols; j++) {
                                if (isRBase(i, j)) {
                                    if (Math.random() < pulseIntensity) {
                                        line += randomMatrixChar();
                                    } else {
                                        line += ' ';
                                    }
                                } else {
                                    line += ' ';
                                }
                            }
                            shimmerLines.push(line);
                        }
                        container.textContent = shimmerLines.join('\n');
                        animFrame++;
                        if (animFrame > 120) {
                            clearInterval(shimmerInterval);
                            startNegativeRFall();
                        }
                    }, 100);
                }
            }, 40);

            function startNegativeRFall() {
                const particles = [];
                const ambientStreams = Array.from({ length: cols }, () => ({
                    head: -Math.random() * rows * 0.6,
                    velocity: 0.35 + Math.random() * 0.25,
                    tail: 5 + Math.floor(Math.random() * 5),
                    density: 0.4 + Math.random() * 0.3,
                }));
                const gravity = 0.045;
                const maxVelocity = 1.6;
                const trailLength = 8;
                const randomPhase = () => Math.random() * Math.PI * 2;

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        if (isRBase(i, j)) {
                            particles.push({
                                x: j + 0.5,
                                y: i + Math.random() * 0.3,
                                vy: 0.02 + Math.random() * 0.06,
                                hold: Math.floor(Math.random() * 6),
                                phase: randomPhase(),
                                trail: [],
                                settled: false
                            });
                        }
                    }
                }

                let fallFrame = 0;
                let completionNotified = false;
                let ambientHold = 260;

                const update = () => {
                    fallFrame++;
                    const grid = Array.from({ length: rows }, () => Array(cols).fill(' '));

                    ambientStreams.forEach((stream, col) => {
                        stream.head += stream.velocity;
                        if (stream.head > rows + stream.tail + 4) {
                            stream.head = -Math.random() * rows * 0.6;
                            stream.velocity = 0.35 + Math.random() * 0.3;
                            stream.tail = 4 + Math.floor(Math.random() * 6);
                            stream.density = 0.35 + Math.random() * 0.4;
                        }
                        const headRow = Math.floor(stream.head);
                        for (let t = 0; t <= stream.tail; t++) {
                            const r = headRow - t;
                            if (r >= 0 && r < rows) {
                                const intensity = 1 - t / (stream.tail + 1);
                                const chance = stream.density * intensity;
                                if (Math.random() < chance) {
                                    grid[r][col] = randomMatrixChar();
                                }
                            }
                        }
                    });

                    let activeCount = 0;
                    particles.forEach((particle) => {
                        if (particle.settled) return;
                        activeCount++;

                        if (particle.hold > 0) {
                            particle.hold -= 1;
                        } else {
                            particle.vy = Math.min(maxVelocity, particle.vy + gravity + Math.random() * 0.02);
                            particle.y += particle.vy;
                            particle.x += Math.sin(fallFrame * 0.08 + particle.phase) * 0.05;
                            particle.x = Math.max(0.2, Math.min(cols - 0.2, particle.x));
                        }

                        const col = Math.floor(particle.x);
                        const row = Math.floor(particle.y);

                        particle.trail.unshift({ row, col });
                        particle.trail = particle.trail.filter((seg, idx) => idx < trailLength && seg.row >= 0 && seg.row < rows && seg.col >= 0 && seg.col < cols);

                        particle.trail.forEach((seg, idx) => {
                            const intensity = Math.max(0, 1 - idx / trailLength);
                            if (seg.row >= 0 && seg.row < rows && seg.col >= 0 && seg.col < cols) {
                                if (grid[seg.row][seg.col] === ' ' || Math.random() < 0.45 + intensity * 0.4) {
                                    grid[seg.row][seg.col] = randomMatrixChar();
                                }
                            }
                        });

                        if (row >= rows) {
                            particle.settled = true;
                        }
                    });

                    container.textContent = grid.map((row) => row.join('')).join('\n');

                    if (!completionNotified && activeCount === 0) {
                        completionNotified = true;
                        if (typeof onComplete === 'function') {
                            onComplete();
                        }
                    }

                    if (completionNotified) {
                        ambientHold -= 1;
                        if (ambientHold <= 0) {
                            return;
                        }
                    }

                    requestAnimationFrame(update);
                };

                requestAnimationFrame(update);
            }
        } else if (typeof onComplete === 'function') {
            onComplete();
        }
    }

    function triggerExitCube(frame) {
        console.log('🔲 EXIT CUBE');
        // Keep terminal active - don't disable it
        
        // Draw box line by line, then extrude
        const lines = [
            '┌─────────┐',
            '│         │',
            '│         │',
            '│         │',
            '└─────────┘'
        ];
        
        // Create box element without clearing frame (preserve input)
        const boxEl = document.createElement('div');
        boxEl.id = 'exitBox';
        boxEl.style.cssText = 'font-family: "Courier New", monospace; font-size: 13px; line-height: 1.6; text-align: center; margin-top: 35%; color: #0f0; position: absolute; top: 0; left: 50%; transform: translateX(-50%); z-index: 50;';
        frame.appendChild(boxEl);
        
        let lineIdx = 0;
        const lineInterval = setInterval(() => {
            if (lineIdx < lines.length) {
                boxEl.textContent += lines[lineIdx] + '\n';
                lineIdx++;
            } else {
                clearInterval(lineInterval);
                // Extrude effect
                setTimeout(() => {
                    extrudeCube(boxEl);
                }, 500);
            }
        }, 300);
    }
    
    function extrudeCube(boxEl) {
        const cubeFrames = [
            `    ┌─────────┐
   /         /│
  /         / │
 /         /  │
┌─────────┐   │
│         │   │
│         │   /
│         │  /
│         │ /
└─────────┘/`,
            `      ┌─────────┐
     /         /│
    /         / │
   /         /  │
  ┌─────────┐   │
 /│         │   │
/ │         │   /
  │         │  /
  │         │ /
  └─────────┘/`
        ];
        
        let frame = 0;
        setInterval(() => {
            boxEl.textContent = cubeFrames[frame % cubeFrames.length];
            frame++;
        }, 400);
    }
    
    function triggerLeaveSequence(frame) {
        console.log('🏠 LEAVE → LEAVES → GIR.mp3');
        // Keep terminal active - don't disable it
        
        // Draw classic house made of the word "LEAVES" - using full display
        const house = `
                                                 LEAVES
                                              LEAVES LEAVES
                                           LEAVES       LEAVES
                                        LEAVES             LEAVES
                                     LEAVES                   LEAVES
                                  LEAVES                         LEAVES
          LEAVES                LEAVES                               LEAVES
          LEAVES             LEAVES                                     LEAVES
          LEAVES LEAVES   LEAVES                                           LEAVES
          LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
          LEAVES                                                                     LEAVES
          LEAVES                                                                     LEAVES
          LEAVES    LEAVES LEAVES LEAVES LEAVES             LEAVES LEAVES LEAVES     LEAVES
          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES
          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES
          LEAVES    LEAVES       LEAVES    LEAVES             LEAVES LEAVES LEAVES     LEAVES
          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES
          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES
          LEAVES    LEAVES LEAVES LEAVES LEAVES             LEAVES LEAVES LEAVES     LEAVES
          LEAVES                                                                     LEAVES
          LEAVES                                                                     LEAVES
          LEAVES                      LEAVES LEAVES LEAVES                           LEAVES
          LEAVES                      LEAVES       LEAVES                           LEAVES
          LEAVES                      LEAVES       LEAVES                           LEAVES
          LEAVES                      LEAVES       LEAVES                           LEAVES
          LEAVES                      LEAVES       LEAVES                           LEAVES
          LEAVES                      LEAVES       LEAVES                           LEAVES
          LEAVES                      LEAVES LEAVES LEAVES                           LEAVES
          LEAVES                                                                     LEAVES
          LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
`;
        
        const houseDiv = document.createElement('div');
        houseDiv.id = 'leavesHouse';
        houseDiv.style.cssText = 'font-family: "Courier New", monospace; white-space: pre; text-align: left; font-size: 13px; margin-top: 5%; margin-left: 5%; color: #0f0; line-height: 1.6; position: absolute; top: 0; left: 0; z-index: 50; pointer-events: none;';
        houseDiv.textContent = house;
        frame.appendChild(houseDiv);
        
        // After 2s, glitch all LEAVES in the house to GIR.mp3
        setTimeout(() => {
            const words = house.match(/LEAVES/g) || [];
            let glitchedHouse = house;
            const glitchDuration = 2000;
            const glitchStart = Date.now();
            
            const glitchInterval = setInterval(() => {
                const elapsed = Date.now() - glitchStart;
                const progress = elapsed / glitchDuration;
                
                if (progress >= 1) {
                    clearInterval(glitchInterval);
                    // All LEAVES become GIR.mp3
                    glitchedHouse = house.replace(/LEAVES/g, 'GIR.mp3');
                    houseDiv.textContent = glitchedHouse;
                } else {
                    // Gradually glitch LEAVES to GIR.mp3
                    let tempHouse = house;
                    const totalWords = words.length;
                    const wordsToGlitch = Math.floor(totalWords * progress);
                    
                    let replacedCount = 0;
                    tempHouse = tempHouse.replace(/LEAVES/g, (match) => {
                        if (replacedCount < wordsToGlitch) {
                            replacedCount++;
                            // Mix characters between LEAVES and GIR.mp3
                            const chars = 'GIR.mp3';
                            let mixed = '';
                            for (let i = 0; i < match.length; i++) {
                                if (Math.random() < progress) {
                                    mixed += chars[i] || chars[chars.length - 1];
                                } else {
                                    mixed += match[i];
                                }
                            }
                            return mixed.padEnd(7);
                        }
                        return match;
                    });
                    
                    houseDiv.textContent = tempHouse;
                }
            }, 50);
        }, 2000);
    }
    
    function glitchText(frame, from, to) {
        const glitchDuration = 1000;
        const glitchStart = Date.now();
        const displayEl = frame.querySelector('div');
        
        const glitchInterval = setInterval(() => {
            const elapsed = Date.now() - glitchStart;
            const progress = elapsed / glitchDuration;
            
            if (progress >= 1) {
                clearInterval(glitchInterval);
                displayEl.textContent = to;
            } else {
                // Mix characters
                const mixed = to.split('').map((toChar, i) => {
                    if (Math.random() < progress) {
                        return toChar;
                    } else if (from[i]) {
                        return from[i];
                    } else {
                        return String.fromCharCode(65 + Math.floor(Math.random() * 26));
                    }
                }).join('');
                displayEl.textContent = mixed;
            }
        }, 50);
    }
    
    function triggerVictory(frame) {
        console.log('🎉 VICTORY!');
        // Keep terminal active - don't disable it
        
        // Create victory message without clearing frame (preserve input)
        const victoryDiv = document.createElement('div');
        victoryDiv.style.cssText = 'text-align: center; margin-top: 35%; color: #0f0; font-size: 13px; line-height: 1.6; font-family: "Courier New", monospace; position: absolute; top: 0; left: 50%; transform: translateX(-50%); z-index: 50; pointer-events: none;';
        victoryDiv.innerHTML = `★ VICTORY ★<br><br>You found it!<br>Welcome to madness.loom`;
        frame.appendChild(victoryDiv);
    }
    
    function triggerCelliBackspaceReaction() {
        if (celliBackspaceSequenceStarted || burstAnimStarted) return;

        celliBackspaceSequenceStarted = true;
        celliBackspaceSequenceTime = totalTime;

        const active = voxels.filter(v => v.visible && !v.userData.glitched);
        if (!celliBackspaceFlickerTriggered && active.length) {
            celliBackspaceFlickerTriggered = true;
            const target = active[Math.floor(Math.random() * active.length)];
            if (target) {
                let flickers = 0;
                const mat = target.material;
                const edgeMaterial = target.userData.edges ? target.userData.edges.material : null;
                const baseOpacity = mat.opacity;
                const baseEdgeOpacity = edgeMaterial ? edgeMaterial.opacity : 0;
                const interval = setInterval(() => {
                    const on = flickers % 2 === 0;
                    mat.opacity = on ? 1 : Math.max(0.1, baseOpacity * 0.2);
                    if (edgeMaterial) {
                        edgeMaterial.opacity = on ? Math.min(0.9, baseEdgeOpacity + 0.3) : Math.max(0.1, baseEdgeOpacity * 0.3);
                    }
                    flickers += 1;
                    if (flickers > 4) {
                        clearInterval(interval);
                        mat.opacity = baseOpacity;
                        if (edgeMaterial) edgeMaterial.opacity = baseEdgeOpacity;
                    }
                }, 90);
            }
        }
    }

    // CELLI glitch and degradation
    function triggerCelliGlitch() {
        if (celliGlitchStarted) return;
        celliGlitchStarted = true;
        
        // Play electrical fritz whir/buzz sound
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        
        // Create buzzing electrical sound with multiple oscillators
        const buzz1 = audioCtx.createOscillator();
        const buzz2 = audioCtx.createOscillator();
        const buzz3 = audioCtx.createOscillator();
        const buzzGain = audioCtx.createGain();
        const buzzFilter = audioCtx.createBiquadFilter();
        
        buzz1.type = 'sawtooth';
        buzz2.type = 'square';
        buzz3.type = 'sawtooth';
        
        // Fluctuating frequencies for electrical buzz
        buzz1.frequency.setValueAtTime(120, now);
        buzz2.frequency.setValueAtTime(180, now);
        buzz3.frequency.setValueAtTime(240, now);
        
        // Modulate frequencies to create buzzing effect
        for (let i = 0; i < 20; i++) {
            const t = now + (i * 0.1);
            const freq1 = 120 + Math.random() * 60;
            const freq2 = 180 + Math.random() * 60;
            const freq3 = 240 + Math.random() * 60;
            buzz1.frequency.setValueAtTime(freq1, t);
            buzz2.frequency.setValueAtTime(freq2, t);
            buzz3.frequency.setValueAtTime(freq3, t);
        }
        
        // Band-pass filter for electrical character
        buzzFilter.type = 'bandpass';
        buzzFilter.frequency.setValueAtTime(300, now);
        buzzFilter.Q.setValueAtTime(5, now);
        
        // Envelope: fade in, sustain, fade out
        buzzGain.gain.setValueAtTime(0, now);
        buzzGain.gain.linearRampToValueAtTime(0.08, now + 0.2);
        buzzGain.gain.setValueAtTime(0.08, now + 1.5);
        buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
        
        buzz1.connect(buzzFilter);
        buzz2.connect(buzzFilter);
        buzz3.connect(buzzFilter);
        buzzFilter.connect(buzzGain);
        buzzGain.connect(audioCtx.destination);
        
        buzz1.start(now);
        buzz2.start(now);
        buzz3.start(now);
        buzz1.stop(now + 2.0);
        buzz2.stop(now + 2.0);
        buzz3.stop(now + 2.0);
        
        // Start flickering lights
        document.getElementById('screenGlitch').classList.add('active');
        
        // Only keep the middle column of I (letter index 4, middle 3 rows: 1,2,3)
        voxels.forEach((voxel, idx) => {
            const data = voxel.userData;
            const gridX = data.gridX;    // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)
            const gridY = data.gridY;    // Row index (0=top, 4=bottom)
            const gridCol = data.gridCol; // Column index within letter (0-4)
            
            // Keep only the T shape: top bar (row 0, all cols) and vertical stem (rows 1-4, middle col)
            const keepVoxel = (gridX === 4 && ((gridY === 0) || (gridY >= 1 && gridY <= 4 && gridCol === 2)));
            
            if (!keepVoxel) {
                // Store in stack for later restoration BEFORE marking as glitched
                glitchedVoxelsStack.push(voxel);
                
                // Mark as glitched immediately to prevent updates
                data.glitched = true;
                
                // Start flickering with light gray
                const flickerDelay = Math.random() * 400;
                
                setTimeout(() => {
                    // Turn to light gray and start flickering
                    voxel.material.color.setRGB(0.6, 0.6, 0.6); // Light gray
                    data.edges.material.color.setRGB(0.65, 0.65, 0.65);
                    
                    const flickerDuration = 400 + Math.random() * 400;
                    let flickerCount = 0;
                    const maxFlickers = Math.floor(flickerDuration / 60);
                    
                    const flickerInterval = setInterval(() => {
                        flickerCount++;
                        const flickerOn = Math.random() > 0.5;
                        
                        // Flicker between light gray and white, gradually dimming
                        const dimFactor = 1 - (flickerCount / maxFlickers) * 0.5;
                        if (flickerOn) {
                            voxel.material.color.setRGB(0.6 * dimFactor, 0.6 * dimFactor, 0.6 * dimFactor);
                            voxel.material.opacity = 0.75 * dimFactor;
                            data.edges.material.opacity = 0.5 * dimFactor;
                        } else {
                            voxel.material.color.setRGB(0.4 * dimFactor, 0.4 * dimFactor, 0.4 * dimFactor);
                            voxel.material.opacity = 0.5 * dimFactor;
                            data.edges.material.opacity = 0.3 * dimFactor;
                        }
                    }, 60);
                    
                    // After flickering, turn dark gray and fade out
                    setTimeout(() => {
                        clearInterval(flickerInterval);
                        
                        // Short out - dark gray
                        voxel.material.color.setRGB(0.15, 0.15, 0.15); // Dark gray
                        data.edges.material.color.setRGB(0.2, 0.2, 0.2);
                        voxel.material.opacity = 0.4;
                        data.edges.material.opacity = 0.25;
                        
                        // Fade to black over time
                        const fadeStart = Date.now();
                        const fadeDuration = 300;
                        const fadeInterval = setInterval(() => {
                            const fadeProgress = (Date.now() - fadeStart) / fadeDuration;
                            if (fadeProgress >= 1) {
                                clearInterval(fadeInterval);
                                voxel.material.opacity = 0;
                                data.edges.material.opacity = 0;
                                voxel.visible = false;
                                data.edges.visible = false;
                            } else {
                                voxel.material.opacity = 0.4 * (1 - fadeProgress);
                                data.edges.material.opacity = 0.25 * (1 - fadeProgress);
                            }
                        }, 16);
                    }, flickerDuration);
                }, flickerDelay);
            }
        });
        
        // Stop screen glitch after 2 seconds
        setTimeout(() => {
            document.getElementById('screenGlitch').classList.remove('active');
        }, 2000);
    }

    function updatePositions(t) {
        const phase = t < introCfg.rollEnd ? 'roll' :
                      t < introCfg.bounceEnd ? 'bounce' :
                      t < introCfg.triangleEnd ? 'triangle' :
                      t < introCfg.transitionEnd ? 'transition' :
                      t < introCfg.normalEnd ? 'normal' :
                      t < introCfg.vennEnd ? 'venn' :
                      t < introCfg.collapseEnd ? 'collapse' :
                      t < introCfg.glitchEnd ? 'glitch' :
                      t < introCfg.blackoutEnd ? 'blackout' :
                      t < introCfg.loomworksEnd ? 'loomworks' :
                      t < introCfg.celliEnd ? 'celli' : 'doorway';

        // Animate bloom, afterimage, and film effects based on phase
        if (phase === 'roll') {
            afterimagePass.uniforms.damp.value = 0.75; // Thin trail
            filmPass.uniforms.noise.value = 0.005; // Minimal grain
            filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines
            triMesh.visible = false; // Hide triangle gradient during intro
        } else if (phase === 'bounce') {
            bloomPass.strength = 0.25; // Subtle glow
            afterimagePass.uniforms.damp.value = 0.75; // Thin trail
            filmPass.uniforms.noise.value = 0.005; // Minimal grain
            filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines
            triMesh.visible = false; // Hide triangle gradient during intro
        } else if (phase === 'triangle') {
            const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);
            
            // Sub-phases: form (0-0.35), converge (0.35-0.6), grow (0.6-1.0)
            const formProgress = Math.min(triangleProgress / 0.35, 1.0);
            const convergeStart = 0.35;
            const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;
            const growStart = 0.6;
            const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;
            
            // Smooth bloom progression throughout all sub-phases
            bloomPass.strength = THREE.MathUtils.lerp(0.25, 0.7, triangleProgress);
            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.75, 0.92, triangleProgress);
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.005, 0.015, triangleProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.003, 0.015, triangleProgress);
            
            // Hide triangle gradient - it makes things look off-center
            triMesh.visible = false;
        } else if (phase === 'transition') {
            const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);
            bloomPass.strength = 0.7; // Keep bloom consistent
            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.92, 0.96, transProgress);
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);
            triMesh.visible = false;
            triMesh.material.opacity = 0;
        } else if (phase === 'normal') {
            const normalT = t - introCfg.transitionEnd;
            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
            const convergeDuration = 2.2;
            const pulseDuration = 3.0;
            const totalAnimDuration = convergeDuration + pulseDuration;

            if (normalT < convergeDuration) {
                // Phase 1: Converge - increase bloom
                const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);
                const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);
                bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.9, convergeEased);
                triMesh.visible = false;
            } else if (normalT < totalAnimDuration) {
                // Phase 2: Single pulse - bloom follows expansion
                const pulseT = normalT - convergeDuration;
                const pulseProgress = pulseT / pulseDuration;
                const pulseCycle = Math.sin(pulseProgress * Math.PI);
                
                bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.72, pulseCycle);
                triMesh.visible = pulseCycle > 0.3; // Show triangle during expansion
                triMesh.material.opacity = THREE.MathUtils.clamp(pulseCycle * 1.5, 0, 0.7);
            } else {
                // Phase 3: Brief hold, prepare for venn transition
                const holdT = normalT - totalAnimDuration;
                const holdDuration = normalDuration - totalAnimDuration;
                const holdProgress = holdT / holdDuration;
                
                bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.85, holdProgress);
                triMesh.visible = false;
            }

            afterimagePass.uniforms.damp.value = 0.96;
            filmPass.uniforms.noise.value = 0.03;
            filmPass.uniforms.scanAmp.value = 0.03;
        } else if (phase === 'venn') {
            // Settle into clear venn diagram
            const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);
            bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.8, vennProgress);
            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.96, 0.7, vennProgress);
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);
            triMesh.visible = true;
            triMesh.material.opacity = THREE.MathUtils.lerp(0.7, 0.85, vennProgress);
        } else if (phase === 'collapse') {
            // Grow and collapse into white radiating circle
            const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);
            bloomPass.strength = THREE.MathUtils.lerp(0.8, 1.2, collapseProgress);
            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.7, 0.6, collapseProgress);
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);
            triMesh.visible = true;
            triMesh.material.opacity = THREE.MathUtils.lerp(0.85, 0.3, collapseProgress);
            
            // Progressive glitch starting mild - show quote only when glitching starts
            if (collapseProgress > 0.15 && !glitchStarted) {
                const quoteEl = document.getElementById('quote');
                quoteEl.style.visibility = 'visible';
                quoteEl.style.opacity = '0.85'; // Start visible
                quoteEl.classList.add('glitch');
                glitchStarted = true;
                quoteShown = true;
            }

            // Increase to medium glitch
            if (collapseProgress > 0.6 && !mediumGlitchStarted) {
                document.getElementById('quote').classList.remove('glitch');
                document.getElementById('quote').classList.add('glitchMedium');
                mediumGlitchStarted = true;
            }
        } else if (phase === 'glitch') {
            // Intense glitch phase
            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
            bloomPass.strength = THREE.MathUtils.lerp(1.2, 0.5, glitchProgress);
            afterimagePass.uniforms.damp.value = 0.3; // Heavy trails
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.5, glitchProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.3, glitchProgress);
            triMesh.visible = true;
            triMesh.material.opacity = THREE.MathUtils.lerp(0.3, 0, glitchProgress);
            
            // Intensify text glitch at start of glitch phase
            if (glitchProgress > 0.05 && !intenseGlitchStarted) {
                document.getElementById('quote').classList.remove('glitch', 'glitchMedium');
                document.getElementById('quote').classList.add('glitchIntense');
                intenseGlitchStarted = true;
            }

            if (glitchProgress > 0.25 && !quoteDespairShown) {
                glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });
                quoteDespairShown = true;
            }

            // Screen glitch in middle
            if (glitchProgress > 0.4 && !screenGlitchStarted) {
                document.getElementById('screenGlitch').classList.add('active');
                screenGlitchStarted = true;
            }
        } else if (phase === 'blackout') {
            // Fade to black
            const blackoutProgress = (t - introCfg.glitchEnd) / (introCfg.blackoutEnd - introCfg.glitchEnd);
            bloomPass.strength = THREE.MathUtils.lerp(0.5, 0, blackoutProgress);
            afterimagePass.uniforms.damp.value = 0.1;
            filmPass.uniforms.noise.value = 0;
            filmPass.uniforms.scanAmp.value = 0;
            triMesh.visible = false;
            
            if (!blackoutStarted) {
                // Hide and clean up quote immediately
                const quoteEl = document.getElementById('quote');
                quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');
                quoteEl.style.visibility = 'hidden';
                quoteEl.style.opacity = '0';
                quoteEl.classList.remove('quote--loom');
                document.getElementById('screenGlitch').classList.remove('active');
                blackoutStarted = true;
            }
        } else if (phase === 'loomworks') {
            // Show Loomworks text
            bloomPass.strength = 0;
            afterimagePass.uniforms.damp.value = 0;
            filmPass.uniforms.noise.value = 0;
            filmPass.uniforms.scanAmp.value = 0;
            triMesh.visible = false;
            
            if (!loomworksShown) {
                // Ensure quote is definitely hidden before showing loomworks
                const quoteEl = document.getElementById('quote');
                quoteEl.style.visibility = 'hidden';
                quoteEl.style.opacity = '0';
                quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');

                startLoomworksReveal();
                loomworksShown = true;
            }
            
            // Play chime jingle at start of this phase
            if (!chimePlayed) {
                // Generate startup chime jingle
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioCtx.currentTime;
                
                // Melodic jingle: C - E - G - C (ascending arpeggio)
                const melody = [
                    { freq: 261.63, time: 0.0, duration: 0.25 },    // C4
                    { freq: 329.63, time: 0.15, duration: 0.25 },   // E4
                    { freq: 392.00, time: 0.30, duration: 0.25 },   // G4
                    { freq: 523.25, time: 0.45, duration: 0.5 }     // C5 (held)
                ];
                
                melody.forEach((note, idx) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(note.freq, now + note.time);
                    
                    // Envelope
                    gain.gain.setValueAtTime(0, now + note.time);
                    gain.gain.linearRampToValueAtTime(0.12, now + note.time + 0.02);
                    gain.gain.linearRampToValueAtTime(0.08, now + note.time + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(now + note.time);
                    osc.stop(now + note.time + note.duration);
                });
                
                // Play startup bass after chime completes
                setTimeout(() => {
                    playStartupBass();
                }, 1200);
                
                chimePlayed = true;
            }
            
            // Hide Loomworks text near end
            const loomProgress = (t - introCfg.blackoutEnd) / (introCfg.loomworksEnd - introCfg.blackoutEnd);
            if (loomProgress > 0.85) {
                document.getElementById('loomworks').style.opacity = THREE.MathUtils.lerp(1, 0, (loomProgress - 0.85) / 0.15);
            }
        } else if (phase === 'celli') {
            // CELLI phase - lower bloom to reduce wobble
            bloomPass.strength = 0.35;
            afterimagePass.uniforms.damp.value = 0.85;
            filmPass.uniforms.noise.value = 0.008;
            filmPass.uniforms.scanAmp.value = 0.003;
            
            triMesh.visible = false;

            if (!celliStarted) {
                document.getElementById('loomworks').style.display = 'none';
                celliStarted = true;
            }
        } else {
            // Doorway phase - portal opens from vertical bar (lower bloom)
            const doorwayProgress = (t - introCfg.celliEnd) / (introCfg.doorwayEnd - introCfg.celliEnd);
            
            bloomPass.strength = THREE.MathUtils.lerp(0.35, 0.55, Math.min(doorwayProgress * 2, 1));
            afterimagePass.uniforms.damp.value = 0.8;
            filmPass.uniforms.noise.value = 0.005;
            filmPass.uniforms.scanAmp.value = 0.002;
            triMesh.visible = false;
            
            // Wait for all CELLI voxels to finish settling (last one settles around 3-4 seconds)
            const celliAge = t - introCfg.loomworksEnd;
            const allVoxelsSettled = celliAge > 5.0;
            
            if (!doorwayShown && allVoxelsSettled) {
                // Show doorway bar after CELLI finishes
                if (doorwayProgress > 0.05) {
                    document.getElementById('doorway').classList.add('visible');
                    doorwayShown = true;
                }
            }
            
            if (doorwayShown && !doorwayOpened) {
                // Open doorway after short delay
                if (doorwayProgress > 0.15) {
                    document.getElementById('doorway').classList.add('open');
                    doorwayOpened = true;
                    
                }
            }
        }

        if (phase === 'roll') {
            // Shapes roll in from off-screen to their positions
            const rollProgress = t / introCfg.rollEnd;
            const eased = rollProgress < 0.5 ? 
                2 * rollProgress * rollProgress : 
                1 - Math.pow(-2 * rollProgress + 2, 2) / 2;
            
            // Keep glow visible throughout roll
            bloomPass.strength = 0.4;

        for (let i = 0; i < 3; i++) {
                const targetX = (i - 1) * 0.35;
                const startX = targetX - 2.0; // Start off-screen left
                const x = THREE.MathUtils.lerp(startX, targetX, eased);
                const y = -0.3;
                
                // Calculate rolling rotation based on distance traveled to reach FLAT position
                const distance = x - startX; // Distance rolled
                
                // Calculate rotation for accurate rolling that ends flat
                let rotation = 0;
                if (i === 0) {
                    // Square: needs to align flat (multiple of π/2)
                    const squarePerimeter = R * 2 * 4;
                    const naturalRotation = -(distance / squarePerimeter) * (Math.PI * 2);
                    // Snap to nearest π/2 when nearly stopped
                    rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI / 2)) * (Math.PI / 2) : naturalRotation;
                } else if (i === 1) {
                    // Triangle: needs to align flat (multiple of 2π/3)
                    const trianglePerimeter = R * 2 * 3;
                    const naturalRotation = -(distance / trianglePerimeter) * (Math.PI * 2);
                    // Snap to nearest 2π/3 when nearly stopped (flat base)
                    rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI * 2 / 3)) * (Math.PI * 2 / 3) : naturalRotation;
                } else {
                    // Circle: any rotation is "flat"
                    rotation = -(distance / (2 * Math.PI * R)) * (Math.PI * 2);
                }
                
                // Store final rotation when reaching target
                if (rollProgress > 0.98) {
                    finalRollRotations[i] = rotation;
                }
                
                // Play continuous rolling thunks based on distance
                const rollDist = Math.abs(x - startX);
                const thunkInterval = 0.15; // Play thunk every 0.15 units rolled
                const expectedThunks = Math.floor(rollDist / thunkInterval);
                
                if (expectedThunks > lastThunkTime[i]) {
                    playRollingThunk(0.06);
                    lastThunkTime[i] = expectedThunks;
                }
                
                spheres[i].position.set(x, y, -i * 0.002);
                spheres[i].rotation.z = rotation;
                spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);
                triMat.uniforms.points.value[i].set(x, y);
                
                // Play final landing thunk
                if (!landingSounds[i] && Math.abs(x - targetX) < 0.02) {
                    playRollingThunk(0.12);
                    landingSounds[i] = true;
                }
            }
            blackHole.visible = false; // Hide during roll-in
            
        } else if (phase === 'bounce') {
            // Sequential bounces: left, then right, then middle
            const bounceT = t - introCfg.rollEnd;
            const baseY = -0.3;
            
            // Keep glow visible during bounce
            bloomPass.strength = 0.4;
            
            for (let i = 0; i < 3; i++) {
                const x = (i - 1) * 0.35;
                let y = baseY;
                
                // Sequence: 0 (left), 2 (right), 1 (middle)
                const bounceOrder = [0, 2, 1];
                const bounceIndex = bounceOrder.indexOf(i);
                const bounceStart = bounceIndex * introCfg.bounceDuration;
                const bounceEnd = bounceStart + introCfg.bounceDuration;
                
                if (bounceT >= bounceStart && bounceT <= bounceEnd) {
                    const localT = (bounceT - bounceStart) / introCfg.bounceDuration;
                    const bounce = Math.sin(localT * Math.PI) * introCfg.bounceHeight;
                    y = baseY + bounce;
                    
                    // Play thud sounds for jump and land
                    if (!window['bounceJump_' + i] && localT < 0.05) {
                        playBounceThud(0.12);
                        window['bounceJump_' + i] = true;
                    }
                    if (!window['bounceLand_' + i] && localT > 0.95) {
                        playBounceThud(0.15);
                        window['bounceLand_' + i] = true;
                    }
                }
                
                spheres[i].position.set(x, y, -i * 0.002);
                spheres[i].rotation.z = finalRollRotations[i]; // Use exact rotation from roll phase
                spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);
                triMat.uniforms.points.value[i].set(x, y);
            }
            blackHole.visible = false; // Hide during bounce
            
        } else if (phase === 'triangle') {
            // Triangle phase: form → converge → grow & brighten
            const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);
            
            // Smooth cubic easing for entire phase
            const smoothEase = (p) => p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2;
            
            // Sub-phases with smooth transitions
            const formProgress = Math.min(triangleProgress / 0.35, 1.0);
            const formEased = smoothEase(formProgress);
            
            const convergeStart = 0.35;
            const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;
            const convergeEased = smoothEase(convergeProgress);
            
            const growStart = 0.6;
            const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;
            const growEased = smoothEase(growProgress);
            
            // Create EQUILATERAL triangle centered at origin
            const centerY = 0;
            const triangleRadius = 0.42; // Distance from center to each vertex (increased)
            
            // Equilateral triangle: vertices at 120° intervals, pointing up
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,  // Top (90°)
                Math.PI / 2 + (2 * Math.PI / 3) * 1,  // Bottom-left (210°)
                Math.PI / 2 + (2 * Math.PI / 3) * 2   // Bottom-right (330°)
            ];
            
            // Rotation grows smoothly throughout
            const rotationAmount = growEased * 0.2;
            
            // Pulsing: breathe in/out during grow phase
            const pulseSpeed = 2.0;
            const pulsePhase = (t - introCfg.bounceEnd - growStart * (introCfg.triangleEnd - introCfg.bounceEnd)) * pulseSpeed;
            const pulseFactor = growProgress > 0 ? 1 + Math.sin(pulsePhase) * 0.08 : 1;
            
            // Converge factor - pull toward center during converge phase
            const convergeFactor = convergeEased * 0.12;
            
            // Map spheres to triangle positions: [0]=left→bottom-left, [1]=middle→top, [2]=right→bottom-right
            const triangleMapping = [1, 0, 2]; // sphere i goes to angle triangleMapping[i]
            
            for (let i = 0; i < 3; i++) {
                // Starting positions from the line (after bounce)
                const startX = (i - 1) * 0.35;
                const startY = -0.3;
                
                // Target positions in triangle formation (with correct mapping)
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotationAmount;
                const targetRadius = triangleRadius * (1 - convergeFactor) * pulseFactor;
                const targetX = Math.cos(angle) * targetRadius;
                const targetY = Math.sin(angle) * targetRadius + centerY;
                
                // Interpolate from line to triangle formation
                const x = THREE.MathUtils.lerp(startX, targetX, formEased);
                const y = THREE.MathUtils.lerp(startY, targetY, formEased);
                
                spheres[i].position.set(x, y, -i * 0.002);
                spheres[i].rotation.z = 0; // Reset rotation for orbit phases
                
                // Scale: small → stays small during form/converge → grows large with overshoot
                let scale = introCfg.ballSize;
                if (formEased < 1) {
                    scale = THREE.MathUtils.lerp(introCfg.ballSize, introCfg.ballSize * 1.0, formEased);
                } else {
                    // Add subtle overshoot for organic feel
                    const overshoot = Math.sin(growEased * Math.PI) * 0.08;
                    scale = THREE.MathUtils.lerp(introCfg.ballSize * 1.0, introCfg.ballSize * 2.2, growEased) + overshoot;
                }
                
                spheres[i].scale.set(scale, scale, scale);
                triMat.uniforms.points.value[i].set(x, y);
            }
            
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = formEased * 0.4;
            
        } else if (phase === 'transition') {
            // Transform triangle into rotating circular orbit - organically
            // ALSO morph all shapes into circles
            const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);
            // Smooth cubic easing
            const eased = transProgress < 0.5 ? 
                4 * transProgress * transProgress * transProgress : 
                1 - Math.pow(-2 * transProgress + 2, 3) / 2;
            
            // Morph shapes into circles halfway through transition
            // Keep materials (colors) consistent - don't swap
            if (transProgress > 0.5 && spheres[0].geometry !== circleGeoTarget && spheres[1].geometry !== circleGeoTarget) {
                const mat0 = spheres[0].material;
                const mat1 = spheres[1].material;
                
                spheres[0].geometry.dispose();
                spheres[0].geometry = createCircle(R);
                spheres[0].material = mat0;  // Preserve cyan
                
                spheres[1].geometry.dispose();
                spheres[1].geometry = createCircle(R);
                spheres[1].material = mat1;  // Preserve yellow
                
                // spheres[2] is already a circle (magenta)
            }
            
            const centerY = 0;
            const triangleRadius = 0.42;
            
            // Use same equilateral triangle angles
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            // Starting radius (with 12% convergence from triangle phase)
            const startRadius = triangleRadius * (1 - 0.12);
            
            // Calculate rotation to match end of triangle phase (which uses rotationAmount = 0.2)
            // The triangle phase maps spheres with triangleMapping, so we need to continue from there
            const triangleEndRotation = 0.2; // matches growEased = 1.0 * 0.2
            const rotation = triangleEndRotation + (eased * Math.PI * 2);
            
            // Expand from triangle size to full orbit size
            const targetDist = motionCfg.maxDist * 0.5;
            const currentDist = THREE.MathUtils.lerp(startRadius, targetDist, eased);
            
            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];
            
            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotation;
                const x = Math.cos(angle) * currentDist;
                const y = Math.sin(angle) * currentDist + centerY;
                
                spheres[i].position.set(x, y, -i * 0.002);
                spheres[i].rotation.z = 0;
                const scale = THREE.MathUtils.lerp(introCfg.ballSize * 2.2, 1.0, eased);
                spheres[i].scale.set(scale, scale, scale);
                triMat.uniforms.points.value[i].set(x, y);
            }
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.4, 0.5, eased);
            
        } else if (phase === 'normal') {
            const normalT = t - introCfg.transitionEnd;
            const convergeDuration = 2.2;
            const pulseDuration = 3.0; // One expand/contract cycle
            const transitionEndDist = motionCfg.maxDist * 0.5;
            const closeConvergeDist = 0.02; // Very close convergence
            const triangleExpandDist = motionCfg.maxDist * 0.65; // Expand to triangle

            const centerY = 0;
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            const transitionEndRotation = 0.2 + Math.PI * 2;
            const rotation = transitionEndRotation + (normalT * motionCfg.rotationSpeed);
            const triangleMapping = [1, 0, 2];

            let currentDist = transitionEndDist;
            let scale = 1.0;
            let pulseFactorValue = 0.5;

            if (normalT < convergeDuration) {
                // Phase 1: Converge close
                const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);
                const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);
                currentDist = THREE.MathUtils.lerp(transitionEndDist, closeConvergeDist, convergeEased);
                scale = THREE.MathUtils.lerp(1.0, 0.82, convergeEased);
                pulseFactorValue = THREE.MathUtils.lerp(0.5, 0.95, convergeEased);
            } else if (normalT < convergeDuration + pulseDuration) {
                // Phase 2: Single expand/contract pulse
                const pulseT = normalT - convergeDuration;
                const pulseProgress = pulseT / pulseDuration;
                
                // Use sine wave for smooth expand/contract (0->1->0)
                const pulseCycle = Math.sin(pulseProgress * Math.PI);
                
                currentDist = THREE.MathUtils.lerp(closeConvergeDist, triangleExpandDist, pulseCycle);
                scale = THREE.MathUtils.lerp(0.82, 1.0, pulseCycle);
                pulseFactorValue = THREE.MathUtils.lerp(0.95, 0.6, pulseCycle);
            } else {
                // Phase 3: Hold at converged position before transitioning to venn
                currentDist = closeConvergeDist;
                scale = 0.82;
                pulseFactorValue = 0.95;
            }

            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotation;
            const p = new THREE.Vector2(
                Math.cos(angle) * currentDist,
                    Math.sin(angle) * currentDist + centerY
            );
            spheres[i].position.set(p.x, p.y, -i * 0.002);
                spheres[i].rotation.z = 0;
            spheres[i].scale.set(scale, scale, scale);
            triMat.uniforms.points.value[i].copy(p);
        }
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = pulseFactorValue;

        } else if (phase === 'venn') {
            // Slow down and form clear venn diagram
            const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);
            // Smooth cubic easing
            const eased = vennProgress < 0.5 ? 
                4 * vennProgress * vennProgress * vennProgress : 
                1 - Math.pow(-2 * vennProgress + 2, 3) / 2;
            
            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
            const centerY = 0;
            
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            // Start from where normal ended: transitionEndRotation + normalDuration * rotationSpeed
            const transitionEndRotation = 0.2 + Math.PI * 2;
            const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed);
            const vennT = t - introCfg.normalEnd;
            const slowRotation = baseRotation + (vennT * motionCfg.rotationSpeed * 0.3); // Slow down to 30%
            
            // Settle into venn diagram distance - calculate what pulse factor was at END of normal phase
            const normalEndTime = introCfg.normalEnd - introCfg.transitionEnd;
            const startPulseFactor = 0.5 + 0.5 * Math.sin(normalEndTime * motionCfg.speed);
            const startDist = motionCfg.maxDist * startPulseFactor;
            const targetDist = 0.08; // Very close for dramatic overlap
            const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);
            const scale = THREE.MathUtils.lerp(1.0, 0.7, eased); // Much larger for awesome venn!

            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];

            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + slowRotation;
                const p = new THREE.Vector2(
                    Math.cos(angle) * currentDist,
                    Math.sin(angle) * currentDist + centerY
                );
                spheres[i].position.set(p.x, p.y, -i * 0.002);
                spheres[i].rotation.z = 0;
                spheres[i].scale.set(scale, scale, scale);
                triMat.uniforms.points.value[i].copy(p);
            }
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(startPulseFactor, 0.6, eased);
            
            if (!quoteShown) {
                applyQuoteState(quoteStates.initial, { immediate: true });
                quoteEl.classList.remove('scrambling', 'glitch', 'glitchMedium', 'glitchIntense');
                document.getElementById('quote').classList.add('visible');
                quoteDespairShown = false;
                quoteShown = true;
            }
            
        } else if (phase === 'collapse') {
            // Grow and collapse into white radiating circle
            const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);
            // Smooth cubic easing
            const eased = collapseProgress < 0.5 ? 
                4 * collapseProgress * collapseProgress * collapseProgress : 
                1 - Math.pow(-2 * collapseProgress + 2, 3) / 2;
            
            const centerY = 0;
            
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            // Start from where venn ended
            const transitionEndRotation = 0.2 + Math.PI * 2;
            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
            const vennDuration = introCfg.vennEnd - introCfg.normalEnd;
            const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed) + (vennDuration * motionCfg.rotationSpeed * 0.3);
            const collapseT = t - introCfg.vennEnd;
            const rotation = baseRotation + (collapseT * motionCfg.rotationSpeed * 0.15); // Even slower
            
            // Collapse to tiny overlap while growing in size
            const startDist = 0.08;
            const targetDist = 0.005;
            const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);
            const scale = THREE.MathUtils.lerp(0.7, 0.85, eased); // Massive spheres!

            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];

        for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotation;
            const p = new THREE.Vector2(
                Math.cos(angle) * currentDist,
                    Math.sin(angle) * currentDist + centerY
            );
            spheres[i].position.set(p.x, p.y, -i * 0.002);
            spheres[i].rotation.z = 0;
            spheres[i].scale.set(scale, scale, scale);
            triMat.uniforms.points.value[i].copy(p);
        }
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.6, 0.85, eased);
            
            if (collapseProgress > 0.3 && !glitchStarted) {
                document.getElementById('quote').classList.add('glitch');
                glitchStarted = true;
            }
            
        } else if (phase === 'glitch' || phase === 'blackout' || phase === 'loomworks' || phase === 'celli') {
            // Hide spheres during ending sequence, keep last position
            const centerY = 0;
            const targetDist = 0.005;
            const scale = 0.85;
            
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            const slowRotation = t * 0.05;
            
            // Fade out spheres during glitch phase
            let sphereOpacity = 1.0;
            if (phase === 'glitch') {
                const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
                sphereOpacity = THREE.MathUtils.lerp(1.0, 0, glitchProgress);
                if (glitchProgress > 0.25 && !quoteDespairShown) {
                    glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });
                    quoteDespairShown = true;
                }
            } else {
                sphereOpacity = 0;
            }
            
            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];
            
            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + slowRotation;
                const p = new THREE.Vector2(
                    Math.cos(angle) * targetDist,
                    Math.sin(angle) * targetDist + centerY
                );
                spheres[i].position.set(p.x, p.y, -i * 0.002);
                spheres[i].rotation.z = 0;
                spheres[i].scale.set(scale, scale, scale);
                spheres[i].material.opacity = sphereOpacity;
            triMat.uniforms.points.value[i].copy(p);
        }

            blackHole.visible = phase === 'glitch';
            if (phase === 'glitch') {
                const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
                blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.85, 0, glitchProgress);
            }
        }
    }

    // --- Responsive ---------------------------------------------------------
    function onResize(){
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      const aspect = window.innerWidth / window.innerHeight;
      triMat.uniforms.aspect.value = aspect;
      if (aspect > 1) { // Landscape
          camera.left = -aspect; camera.right = aspect; camera.top = 1; camera.bottom = -1;
          // Scale black hole to maintain circularity
          blackHole.scale.set(1, 1, 1);
      } else { // Portrait
          camera.left = -1; camera.right = 1; camera.top = 1 / aspect; camera.bottom = -1 / aspect;
          // Scale black hole to maintain circularity
          blackHole.scale.set(aspect, aspect, 1);
      }
      camera.updateProjectionMatrix();
      
      // Recalculate CELLI scale for responsive layout
      const oldScale = celliScale;
      calculateCelliScale();

      // Update voxel positions and scales based on new scale
      if (oldScale !== celliScale) {
          const scaleRatio = celliScale / oldScale;
          voxels.forEach((voxel) => {
              const data = voxel.userData;
              // Update positions with new scale
              data.targetX *= scaleRatio;
              data.targetY *= scaleRatio;
              data.baseScale = celliScale;

              // Update actual positions if settled
              if (data.settled) {
                  voxel.position.x = data.targetX;
                  voxel.position.y = data.targetY;
              }

              // Update scale
              voxel.scale.set(celliScale, celliScale, celliScale);
          });
      }

      if (bowActive) {
          moveBowToTarget(true);
      }
    }
    window.addEventListener('resize', onResize);
    onResize();

    // --- Animate (gated by Play) -------------------------------------------
    const clock = new THREE.Clock();
    let running = false, totalTime = 0;
    
    // Canvas for text particles
    const textCanvas = document.createElement('canvas');
    textCanvas.style.position = 'fixed';
    textCanvas.style.inset = '0';
    textCanvas.style.pointerEvents = 'none';
    textCanvas.style.zIndex = '5';
    document.body.appendChild(textCanvas);
    const textCtx = textCanvas.getContext('2d');
    
    function resizeTextCanvas() {
        textCanvas.width = window.innerWidth;
        textCanvas.height = window.innerHeight;
    }
    resizeTextCanvas();
    window.addEventListener('resize', resizeTextCanvas);
    
     // Gentle thunk sound for rolling (lighter than landing)
     function playRollingThunk(volume = 0.08, delay = 0) {
         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
         const now = audioCtx.currentTime + delay;
         
         // Subtle rolling "tap" sound
         const osc = audioCtx.createOscillator();
         const gain = audioCtx.createGain();
         
         osc.type = 'sine';
         osc.frequency.setValueAtTime(100 + Math.random() * 20, now); // Slight variation
         osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);
         
         gain.gain.setValueAtTime(volume, now);
         gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
         
         osc.connect(gain);
         gain.connect(audioCtx.destination);
         osc.start(now);
         osc.stop(now + 0.15);
     }
     
     // Heavier thud for jumps and landings
     function playBounceThud(volume = 0.15, delay = 0) {
         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
         const now = audioCtx.currentTime + delay;
         
         // Deep impact sound
         const osc = audioCtx.createOscillator();
         const gain = audioCtx.createGain();
         
         osc.type = 'sine';
         osc.frequency.setValueAtTime(60, now); // Deep thud
         osc.frequency.exponentialRampToValueAtTime(30, now + 0.15);
         
         gain.gain.setValueAtTime(volume, now);
         gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
         
         osc.connect(gain);
         gain.connect(audioCtx.destination);
         osc.start(now);
         osc.stop(now + 0.25);
     }
     
     // Hollow melodic chime for voxel landing - C pentatonic scale
     function playVoxelChime(delay = 0) {
         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
         const now = audioCtx.currentTime + delay;
         
         // Pentatonic scale notes for melodic chimes (C, D, E, G, A)
         const pentatonicNotes = [523.25, 587.33, 659.25, 783.99, 880]; // C5, D5, E5, G5, A5
         const fundamentalFreq = pentatonicNotes[Math.floor(Math.random() * pentatonicNotes.length)];
         
         // Hollow sound: triangle wave with filtered overtones
         const osc1 = audioCtx.createOscillator();
         const osc2 = audioCtx.createOscillator();
         const osc3 = audioCtx.createOscillator();
         const filter = audioCtx.createBiquadFilter();
         const gain = audioCtx.createGain();
         
         osc1.type = 'triangle'; // Hollow fundamental
         osc1.frequency.setValueAtTime(fundamentalFreq, now);
         
         osc2.type = 'sine'; // Soft overtone
         osc2.frequency.setValueAtTime(fundamentalFreq * 3, now);
         
         osc3.type = 'sine'; // Gentle fifth
         osc3.frequency.setValueAtTime(fundamentalFreq * 1.5, now);
         
         // Band-pass filter for hollow character
         filter.type = 'bandpass';
         filter.frequency.setValueAtTime(fundamentalFreq * 2, now);
         filter.Q.setValueAtTime(2, now);
         
         // Gentle envelope
         gain.gain.setValueAtTime(0, now);
         gain.gain.linearRampToValueAtTime(0.03, now + 0.01);
         gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
         
         osc1.connect(filter);
         osc2.connect(gain);
         osc3.connect(gain);
         filter.connect(gain);
         gain.connect(audioCtx.destination);
         
         osc1.start(now);
         osc2.start(now);
         osc3.start(now);
         osc1.stop(now + 1.2);
         osc2.stop(now + 1.2);
         osc3.stop(now + 1.2);
     }
    
    // Chiptune music system - simple arpeggio + drums
    let chiptuneBass = null;
    let chiptuneGain = null;
    let lastNoteTime = 0;
    let lastDrumTime = 0;
    let noteIndex = 0;
    let drumIndex = 0;
    let musicStarted = false;
    let reverbDelay = null;
    let reverbGain = null;
    let reverbFeedback = null;
    let glitchWhirOsc1 = null;
    let glitchWhirOsc2 = null;
    let glitchWhirOsc3 = null;
    let glitchWhirGain = null;
    let glitchWhirFilter = null;
    let glitchWhirStarted = false;
    
    function updateSynth(t) {
        // Start music during triangle phase
        if (!musicStarted && t > introCfg.bounceEnd) {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create reverb delay effect
            reverbDelay = audioCtx.createDelay(2.0);
            reverbDelay.delayTime.value = 0.25; // 250ms delay
            reverbGain = audioCtx.createGain();
            reverbGain.gain.value = 0.3; // Moderate reverb mix
            reverbFeedback = audioCtx.createGain();
            reverbFeedback.gain.value = 0.4; // Feedback for reverb tail
            
            // Wire up reverb: delay -> feedback -> delay (loop) + output
            reverbDelay.connect(reverbFeedback);
            reverbFeedback.connect(reverbDelay);
            reverbDelay.connect(reverbGain);
            reverbGain.connect(audioCtx.destination);
            
            musicStarted = true;
            lastNoteTime = t;
            lastDrumTime = t;
        }
        
        if (!musicStarted || !audioCtx) return;
        
        const now = audioCtx.currentTime;
        
        // Determine arpeggio and rhythm based on phase
        let arpeggio = [];
        let noteSpeed = 0.25;
        let drumSpeed = 0.5;
        let drumVolume = 0.12;
        let drumReverb = 0.2;
        let reverbMix = 0.3;
        let glitchLevel = 0;
        
        if (t < introCfg.triangleEnd) {
            // Calm, contemplative Am progression
            arpeggio = [220.00, 261.63, 329.63, 261.63]; // A3, C4, E4, C4
            noteSpeed = 0.5;
            drumSpeed = 1.2;
            drumVolume = 0.08;
            drumReverb = 0.25;
            reverbMix = 0.35;
        } else if (t < introCfg.normalEnd) {
            // Gentle progression with suspension
            arpeggio = [220.00, 246.94, 293.66, 329.63, 293.66, 246.94]; // A3, B3, D4, E4, D4, B3
            noteSpeed = 0.45;
            drumSpeed = 1.0;
            drumVolume = 0.1;
            drumReverb = 0.3;
            reverbMix = 0.4;
        } else if (t < introCfg.vennEnd) {
            // Subdued, introspective
            arpeggio = [196.00, 246.94, 293.66, 349.23, 293.66, 246.94]; // G3, B3, D4, F4, D4, B3
            noteSpeed = 0.4;
            drumSpeed = 0.9;
            drumVolume = 0.12;
            drumReverb = 0.4;
            reverbMix = 0.45;
        } else if (t < introCfg.collapseEnd) {
            // Building unease, drums more present
            arpeggio = [220.00, 277.18, 329.63, 392.00, 329.63, 277.18]; // A3, C#4, E4, G4, E4, C#4
            noteSpeed = 0.38;
            drumSpeed = 0.7;
            drumVolume = 0.16; // Drums becoming more prominent
            drumReverb = 0.6;
            reverbMix = 0.5;
            glitchLevel = 0.1;
        } else if (t < introCfg.glitchEnd) {
            // Dissonant breakdown, drums dominate
            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
            arpeggio = [233.08, 277.18, 369.99, 415.30]; // Diminished, unsettling
            noteSpeed = 0.35;
            drumSpeed = 0.55;
            drumVolume = THREE.MathUtils.lerp(0.18, 0.28, glitchProgress); // Drums take over
            drumReverb = THREE.MathUtils.lerp(0.6, 0.85, glitchProgress);
            reverbMix = THREE.MathUtils.lerp(0.5, 0.65, glitchProgress);
            glitchLevel = THREE.MathUtils.lerp(0.2, 0.8, glitchProgress);
        } else {
            return;
        }
        
        // Update reverb mix
        if (reverbGain) {
            reverbGain.gain.setTargetAtTime(reverbMix, now, 0.5);
        }
        
        // Play arpeggio notes
        if (t - lastNoteTime >= noteSpeed) {
            const freq = arpeggio[noteIndex % arpeggio.length];
            playChiptuneNote(freq, noteSpeed * 0.9, glitchLevel, reverbDelay);
            noteIndex++;
            lastNoteTime = t;
        }
        
        // Play drum beats
        if (t - lastDrumTime >= drumSpeed) {
            playChiptuneDrum(drumVolume, drumReverb, glitchLevel, reverbDelay);
            drumIndex++;
            lastDrumTime = t;
        }
        
        // Corrupted whir during glitch phase
        if (t >= introCfg.collapseEnd && t < introCfg.glitchEnd) {
            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
            
            if (!glitchWhirStarted) {
                // Start the harsh whirring synth
                glitchWhirOsc1 = audioCtx.createOscillator();
                glitchWhirOsc2 = audioCtx.createOscillator();
                glitchWhirOsc3 = audioCtx.createOscillator();
                glitchWhirGain = audioCtx.createGain();
                glitchWhirFilter = audioCtx.createBiquadFilter();
                
                // Triangle waves for harsh, mechanical sound
                glitchWhirOsc1.type = 'triangle';
                glitchWhirOsc2.type = 'triangle';
                glitchWhirOsc3.type = 'triangle';
                
                // Detuning for thickness
                glitchWhirOsc1.detune.value = -8;
                glitchWhirOsc2.detune.value = 0;
                glitchWhirOsc3.detune.value = 8;
                
                // Start at low frequency
                glitchWhirOsc1.frequency.setValueAtTime(220, now);
                glitchWhirOsc2.frequency.setValueAtTime(220, now);
                glitchWhirOsc3.frequency.setValueAtTime(220, now);
                
                // Resonant filter for harsh whir
                glitchWhirFilter.type = 'lowpass';
                glitchWhirFilter.frequency.setValueAtTime(400, now);
                glitchWhirFilter.Q.setValueAtTime(8, now);
                
                glitchWhirGain.gain.setValueAtTime(0, now);
                glitchWhirGain.gain.linearRampToValueAtTime(0.08, now + 0.5);
                
                glitchWhirOsc1.connect(glitchWhirFilter);
                glitchWhirOsc2.connect(glitchWhirFilter);
                glitchWhirOsc3.connect(glitchWhirFilter);
                glitchWhirFilter.connect(glitchWhirGain);
                glitchWhirGain.connect(audioCtx.destination);
                
                glitchWhirOsc1.start(now);
                glitchWhirOsc2.start(now);
                glitchWhirOsc3.start(now);
                
                glitchWhirStarted = true;
            }
            
            // Modulate frequency for failing sound
            if (glitchWhirOsc1) {
                const crackle = Math.sin(t * 100) * 20 * glitchProgress;
                const whir = Math.sin(t * 30) * 10;
                const baseFreq = THREE.MathUtils.lerp(220, 55, glitchProgress); // Pitch down as it fails
                
                glitchWhirOsc1.frequency.setTargetAtTime(baseFreq + crackle + whir, now, 0.02);
                glitchWhirOsc2.frequency.setTargetAtTime(baseFreq + crackle + whir * 1.1, now, 0.02);
                glitchWhirOsc3.frequency.setTargetAtTime(baseFreq + crackle + whir * 0.9, now, 0.02);
                
                // Filter sweep downward
                glitchWhirFilter.frequency.setTargetAtTime(THREE.MathUtils.lerp(400, 100, glitchProgress), now, 0.1);
                
                // Volume swell and fade
                const vroomPhase = Math.sin(t * 2) * 0.5 + 0.5;
                const fadeOut = 1 - glitchProgress * 0.7; // Fade out near end
                glitchWhirGain.gain.setTargetAtTime(0.08 * fadeOut * vroomPhase, now, 0.05);
            }
        } else if (glitchWhirStarted && glitchWhirOsc1) {
            // Stop the whir after glitch phase
            glitchWhirOsc1.stop(now + 0.5);
            glitchWhirOsc2.stop(now + 0.5);
            glitchWhirOsc3.stop(now + 0.5);
            glitchWhirOsc1 = null;
            glitchWhirOsc2 = null;
            glitchWhirOsc3 = null;
        }
    }
    
    // Chiptune note player - muted, musical synth
    function playChiptuneNote(freq, duration, glitchLevel = 0, reverbNode = null) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        
        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        
        // Sine waves for muted, warm tone
        osc1.type = 'sine';
        osc2.type = 'sine';
        
        // Add subtle harmonic (5th) for richness
        const glitchWobble = glitchLevel > 0 ? (Math.random() - 0.5) * freq * glitchLevel * 0.2 : 0;
        osc1.frequency.setValueAtTime(freq + glitchWobble, now);
        osc2.frequency.setValueAtTime((freq * 1.5) + glitchWobble, now); // Perfect 5th
        
        // Muted low-pass filter
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(glitchLevel > 0.5 ? 600 : 1200, now);
        filter.Q.setValueAtTime(0.3, now);
        
        // Very soft, gentle envelope
        const baseVol = 0.045 * (1 - glitchLevel * 0.3);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(baseVol, now + 0.03);
        gain.gain.setValueAtTime(baseVol * 0.85, now + duration * 0.5);
        gain.gain.linearRampToValueAtTime(0, now + duration);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        
        // Connect to reverb if available
        if (reverbNode) {
            gain.connect(reverbNode);
        }
        
        osc1.start(now);
        osc2.start(now);
        osc1.stop(now + duration);
        osc2.stop(now + duration);
    }
    
    // Startup bass sound (Simple warm chord - NO REVERB to prevent oscillation)
    function playStartupBass() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        
        // Master output - simple, clean
        const masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.4;
        masterGain.connect(audioCtx.destination);
        
        // Simple warm chord - C major
        const chordNotes = [
            { freq: 130.81, vol: 0.10 },  // C3
            { freq: 164.81, vol: 0.08 },  // E3
            { freq: 196.00, vol: 0.07 },  // G3
            { freq: 65.41, vol: 0.09 },   // C2 (bass)
        ];
        
        chordNotes.forEach((note, i) => {
            const osc = audioCtx.createOscillator();
            const oscGain = audioCtx.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = note.freq; // Fixed frequency, no modulation
            
            // Simple envelope
            const delay = i * 0.08;
            oscGain.gain.setValueAtTime(0, now + delay);
            oscGain.gain.linearRampToValueAtTime(note.vol, now + delay + 0.15);
            oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);
            oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);
            
            osc.connect(oscGain);
            oscGain.connect(masterGain);
            
            osc.start(now + delay);
            osc.stop(now + delay + 1.6);
        });
    }
    
    // Chiptune drum player
    function playChiptuneDrum(volume = 0.12, reverbAmount = 0.3, glitchLevel = 0, reverbNode = null) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        
        // Kick drum
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const reverbSend = audioCtx.createGain();
        
        osc.type = 'sine';
        const startFreq = glitchLevel > 0.5 ? 80 + Math.random() * 40 : 60;
        osc.frequency.setValueAtTime(startFreq, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
        
        // Main drum volume (dominant)
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        
        // Reverb send amount
        reverbSend.gain.setValueAtTime(volume * reverbAmount, now);
        reverbSend.gain.exponentialRampToValueAtTime(0.001, now + 0.3); // Longer reverb tail
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        // Send to reverb
        if (reverbNode) {
            osc.connect(reverbSend);
            reverbSend.connect(reverbNode);
        }
        
        osc.start(now);
        osc.stop(now + 0.3);
    }
    
    function frame(){
      if(!running) return;
      const dt = Math.min(clock.getDelta(), 0.033);
      totalTime += dt;
      updatePositions(totalTime);
      updateSynth(totalTime);
      blackHole.material.uniforms.time.value = totalTime;
      filmPass.uniforms.time.value += dt;
      composer.render();
      
      // Update and render text particles
      updateTextParticles(dt);
      textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
      renderTextParticles(textCtx, camera);
      
      // Update voxels for CELLI animation
      updateVoxels(totalTime, dt);
      
      // Update floating voxels during burst
      updateFloatingVoxels(dt);
      
      // Update camera pan
      updateCameraPan();
      
      requestAnimationFrame(frame);
    }

    // --- Click interaction on spheres ----------------------------------------
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    renderer.domElement.addEventListener('click', (event) => {
        if (!running) return;
        
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(spheres);
        
        if (intersects.length > 0) {
            const hitSphere = intersects[0].object;
            const sphereIndex = spheres.indexOf(hitSphere);
            const hitPos = intersects[0].point;
            
            // Burst particles based on color
            let texts, color;
            if (sphereIndex === 0) { // Cyan - equations
                texts = equationTexts;
                color = '#00a8ff';
            } else if (sphereIndex === 1) { // Yellow - time
                texts = Array(8).fill(0).map(() => timeTexts());
                color = '#ffb62e';
            } else { // Magenta - manic
                texts = manicTexts;
                color = '#ff1e6e';
            }
            
            // Create burst of 5-8 particles
            const count = 5 + Math.floor(Math.random() * 4);
            for (let i = 0; i < count; i++) {
                const text = texts[Math.floor(Math.random() * texts.length)];
                createTextParticle(hitPos.x, hitPos.y, text, color, sphereIndex);
            }
        }
    });

    // --- Doorway input keyboard and click interaction ------------------------------------
    const promptContainer = document.querySelector('.prompt-container');
    const promptTextEl = document.getElementById('promptText');
    const promptCursorEl = document.getElementById('promptCursor');
    const hiddenInput = document.getElementById('hiddenInput');
    const promptEl = document.querySelector('.prompt');
    
    // Click to trigger CELLI glitch (reveal T) and focus hidden input for mobile
    if (promptContainer) {
        function focusHiddenPromptInput() {
            if (!hiddenInput) return;

            hiddenInput.value = '';

            const focusOptions = { preventScroll: true };
            try {
                hiddenInput.focus(focusOptions);
            } catch (err) {
                hiddenInput.focus();
            }

            if (document.activeElement !== hiddenInput) {
                hiddenInput.focus();
            }
        }

        promptContainer.addEventListener('click', () => {
            if (!running || burstAnimStarted) return;
            if (!inputAttempted) {
                triggerCelliGlitch();
                inputAttempted = true;
            }

            if (hiddenInput) {
                focusHiddenPromptInput();
            }
        });
        
        function handlePromptBackspace() {
            if (!running || !doorwayOpened || burstAnimStarted) return false;
            if (inputText.length <= promptBaseText.length) return false;

            inputText = inputText.slice(0, -1);
            tEntered = false;

            promptTextEl.textContent = inputText;
            promptCursorEl.textContent = '_';
            if (promptEl) {
                promptEl.setAttribute('data-text', inputText + '_');
            }

            if (hiddenInput) {
                hiddenInput.value = '';
            }

            if (burstTimeout) {
                clearTimeout(burstTimeout);
                burstTimeout = null;
            }

            // Restore one letter with fritz effect
            restoreOneLetter();
            return true;
        }

        // Keyboard input to trigger final sequence (desktop)
        window.addEventListener('keydown', (e) => {
            if (!running || !doorwayOpened || !inputAttempted) return;

            if (e.key === 'Backspace') {
                e.preventDefault();
                handlePromptBackspace();
                return;
            }

            // T input - starts burst sequence
            if (!tEntered && e.key.toLowerCase() === 't') {
                e.preventDefault();
                tEntered = true;
                inputText += 'T';

                // Update display
                promptTextEl.textContent = inputText;
                promptCursorEl.textContent = '_';
                if (promptEl) {
                    promptEl.setAttribute('data-text', inputText + '_');
                }

                if (burstTimeout) {
                    clearTimeout(burstTimeout);
                }
                burstTimeout = setTimeout(() => {
                    triggerBurstToStars();
                }, 500);
                return;
            }
            
            // E, N, D inputs - only after STAR is fully cleared and yellow transformation complete
            if (inputText === '=' && allYellowTransformed) {
                const key = e.key.toUpperCase();
                
                console.log('END input detected:', key, 'endSequence:', endSequence, 'allYellowTransformed:', allYellowTransformed);
                
                // E must be first
                if (endSequence === '' && key === 'E') {
                    e.preventDefault();
                    endSequence = 'E';
                    transformToMagentaRed();
                    promptTextEl.textContent = '=E';
                    if (promptEl) promptEl.setAttribute('data-text', '=E_');
                    console.log('Transformed to MAGENTA');
                    return;
                }
                
                // N must be second (after E)
                if (endSequence === 'E' && key === 'N') {
                    e.preventDefault();
                    endSequence = 'EN';
                    transformToCyanBlue();
                    promptTextEl.textContent = '=EN';
                    if (promptEl) promptEl.setAttribute('data-text', '=EN_');
                    console.log('Transformed to CYAN');
                    return;
                }
                
                // D must be third (after EN)
                if (endSequence === 'EN' && key === 'D') {
                    e.preventDefault();
                    endSequence = 'END';
                    transformToGreenAndSquare();
                    promptTextEl.textContent = '=END';
                    if (promptEl) promptEl.setAttribute('data-text', '=END_');
                    console.log('Transformed to GREEN, starting snap animation');
                    return;
                }
            } else if (inputText === '=') {
                console.log('Input is =, but allYellowTransformed is:', allYellowTransformed);
            }
        });
        
        // Mobile input handler
        if (hiddenInput) {
            hiddenInput.addEventListener('beforeinput', (e) => {
                if (!running || !doorwayOpened || !inputAttempted) return;
                if (e.inputType === 'deleteContentBackward') {
                    e.preventDefault();
                    handlePromptBackspace();
                }
            });

            hiddenInput.addEventListener('input', (e) => {
                if (!running || !doorwayOpened || !inputAttempted) return;

                const value = (e.target.value || '').toUpperCase();

                if (value === '') {
                    handlePromptBackspace();
                    return;
                }

                // T input for burst sequence
                if (!tEntered && value.includes('T')) {
                    e.preventDefault();
                    tEntered = true;
                    inputText += 'T';

                    promptTextEl.textContent = inputText;
                    promptCursorEl.textContent = '_';
                    if (promptEl) {
                        promptEl.setAttribute('data-text', inputText + '_');
                    }

                    e.target.value = '';

                    if (burstTimeout) {
                        clearTimeout(burstTimeout);
                    }
                    burstTimeout = setTimeout(() => {
                        triggerBurstToStars();
                    }, 500);

                    hiddenInput.blur();
                    return;
                }
                
                // E, N, D inputs after STAR cleared and yellow transformation
                if (inputText === '=' && allYellowTransformed) {
                    // E must be first
                    if (endSequence === '' && value.includes('E')) {
                        e.preventDefault();
                        endSequence = 'E';
                        transformToMagentaRed();
                        promptTextEl.textContent = '=E';
                        if (promptEl) promptEl.setAttribute('data-text', '=E_');
                        e.target.value = '';
                        return;
                    }
                    
                    // N must be second
                    if (endSequence === 'E' && value.includes('N')) {
                        e.preventDefault();
                        endSequence = 'EN';
                        transformToCyanBlue();
                        promptTextEl.textContent = '=EN';
                        if (promptEl) promptEl.setAttribute('data-text', '=EN_');
                        e.target.value = '';
                        return;
                    }
                    
                    // D must be third
                    if (endSequence === 'EN' && value.includes('D')) {
                        e.preventDefault();
                        endSequence = 'END';
                        transformToGreenAndSquare();
                        promptTextEl.textContent = '=END';
                        if (promptEl) promptEl.setAttribute('data-text', '=END_');
                        e.target.value = '';
                        return;
                    }
                }
                
                // Clear any other input
                e.target.value = '';
            });
        }
    }
    
    // Break apart and rise to sky
    let breakApartStarted = false;
    let riseStartTime = 0;
    
    function triggerBurstToStars() {
        if (burstAnimStarted) return;
        burstAnimStarted = true;
        burstTimeout = null;
        breakApartStarted = true;
        riseStartTime = Date.now();

        const skipBtn = document.getElementById('skipBtn');
        if (skipBtn) {
            skipBtn.classList.remove('illuminating');
        }

        // Increase afterimage effect for dramatic trails
        afterimagePass.uniforms.damp.value = 0.88;
        
        // Hide prompt but keep it for reference
        if (promptEl) {
            promptEl.style.transition = 'opacity 0.5s ease';
            promptEl.style.opacity = '0';
        }
        
        // Get only the T-shape voxels (the ones that weren't glitched)
        const activeVoxels = voxels.filter(v => !v.userData.glitched && v.visible);
        
        // Give each voxel velocity to shoot upward dramatically
        activeVoxels.forEach((voxel, idx) => {
            setTimeout(() => {
                const angle = Math.random() * Math.PI * 2;
                const spreadH = 0.008 + Math.random() * 0.015; // More horizontal spread
                
                voxel.userData.floating = true;
                voxel.userData.vx = Math.cos(angle) * spreadH;
                voxel.userData.vy = 0.08 + Math.random() * 0.05; // MUCH faster upward - shooting motion
                voxel.userData.vz = -0.05 - Math.random() * 0.08; // Move away from camera (into distance)
                voxel.userData.pulsatePhase = Math.random() * Math.PI * 2;
                voxel.userData.pulsateSpeed = 3 + Math.random() * 3;
                voxel.userData.floatStartTime = Date.now();
                voxel.userData.initialScale = voxel.userData.baseScale || 1.0;
            }, idx * 15); // Faster stagger
        });
        
        // Start camera pan after voxels have shot into distance
        setTimeout(() => {
            startCameraPan();
        }, 4000); // Slightly longer to see them recede
    }
    
    // Update floating voxels
    function updateFloatingVoxels(dt) {
        if (!breakApartStarted) return;
        
        const now = Date.now();
        const totalElapsed = (now - riseStartTime) / 1000;
        
        voxels.forEach(voxel => {
            if (!voxel.userData.floating) return;
            
            const data = voxel.userData;
            const age = (now - data.floatStartTime) / 1000;
            
            // Move with velocity - shooting into distance
            voxel.position.x += data.vx;
            voxel.position.y += data.vy;
            voxel.position.z += data.vz;
            
            // Very slow drag to maintain shooting motion
            data.vx *= 0.985;
            data.vy *= 0.985;
            data.vz *= 0.985;
            
            // Scale down dramatically as they move away (perspective)
            // Based on Z distance from camera
            const distanceZ = Math.abs(voxel.position.z + 0.5); // Initial Z was around -0.5
            const perspectiveScale = 1 / (1 + distanceZ * 3); // Shrink rapidly with distance
            
            // Pulsate on top of perspective scaling
            data.pulsatePhase += data.pulsateSpeed * dt;
            const pulse = 0.85 + Math.sin(data.pulsatePhase) * 0.15;
            const baseScale = data.initialScale || 1.0;
            const finalScale = baseScale * pulse * perspectiveScale;
            voxel.scale.set(finalScale, finalScale, finalScale);
            
            // Brighten voxels during shooting (they're stars now)
            voxel.material.color.setRGB(1, 1, 1); // Pure white
            
            // Pulsate material opacity with distance fade
            const opacityPulse = 0.8 + Math.sin(data.pulsatePhase * 0.7) * 0.2;
            const distanceFade = Math.max(0.3, 1 - distanceZ * 0.4); // Fade as they get far
            voxel.material.opacity = Math.min(1.0, opacityPulse * distanceFade);
            data.edges.material.opacity = Math.min(0.8, opacityPulse * 0.8 * distanceFade);
            
            // Fade out during camera pan
            if (cameraPanStarted) {
                const panProgress = (now - panStartTime) / panDuration;
                const fadeStart = 0.5;
                if (panProgress > fadeStart) {
                    const fadeProgress = (panProgress - fadeStart) / (1 - fadeStart);
                    voxel.material.opacity *= (1 - fadeProgress * 0.8);
                    data.edges.material.opacity *= (1 - fadeProgress * 0.8);
                }
            }
        });
    }
    
    // Pan camera down to reveal gradient
    let cameraPanStarted = false;
    let panStartTime = 0;
    const panDuration = 5000; // 5 seconds for dramatic reveal
    
    function startCameraPan() {
        cameraPanStarted = true;
        panStartTime = Date.now();
    }
    
    function updateCameraPan() {
        if (!cameraPanStarted) return;
        
        const elapsed = Date.now() - panStartTime;
        const progress = Math.min(1, elapsed / panDuration);
        
        // Smooth ease-in-out for dramatic pan
        const eased = progress < 0.5 ? 
            2 * progress * progress : 
            1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        // Gradually reduce afterimage effect during pan to fade trails
        afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.88, 0.96, progress);
        
        // Pan down much further to reveal gradient
        camera.position.y = THREE.MathUtils.lerp(0, -5, eased);
        camera.lookAt(0, camera.position.y - 2, 0); // Look ahead of camera position
        
        // Fade doorway, prompt, and vignette quickly
        const doorway = document.getElementById('doorway');
        if (doorway) {
            doorway.style.opacity = Math.max(0, 1 - progress * 2);
        }
        
        // Fade out vignette
        const vignette = document.querySelector('.vignette');
        if (vignette) {
            vignette.style.transition = 'opacity 1s ease';
            vignette.style.opacity = String(Math.max(0, 1 - progress * 1.5));
        }
        
        // Add blue gradient background early in the pan
        if (progress > 0.2 && !document.getElementById('nightSky')) {
            // Set app background to black initially for smooth transition
            const app = document.getElementById('app');
            if (app) {
                app.style.background = '#000';
            }
            
            // Immediately hide vignette and scanlines when gradient appears
            const vignetteEl = document.querySelector('.vignette');
            if (vignetteEl) {
                vignetteEl.style.display = 'none';
            }
            
            // Hide scanlines overlay
            if (app && app.classList.contains('scanlines')) {
                app.classList.add('fade-scanlines');
            }
            
            const nightSky = document.createElement('div');
            nightSky.id = 'nightSky';
            nightSky.style.position = 'fixed';
            nightSky.style.inset = '0';
            nightSky.style.background = 'linear-gradient(to bottom, #0d1b2a 0%, #1a237e 20%, #283593 40%, #3949ab 60%, #5e92f3 80%, #90caf9 100%)';
            nightSky.style.zIndex = '0';
            nightSky.style.opacity = '0';
            nightSky.style.pointerEvents = 'none';
            
            // Insert at beginning of body
            if (document.body.firstChild) {
                document.body.insertBefore(nightSky, document.body.firstChild);
            } else {
                document.body.appendChild(nightSky);
            }
            
            // Fade in gradient
            setTimeout(() => {
                nightSky.style.transition = 'opacity 3s ease';
                nightSky.style.opacity = '1';
                
                // Fade out black background
                if (app) {
                    app.style.transition = 'background 3s ease';
                    app.style.background = 'transparent';
                }
            }, 100);
        }
        
        // Fade out 3D scene elements as gradient appears
        if (progress > 0.3) {
            const fadeAmount = Math.min(1, (progress - 0.3) / 0.7); // Fade from 30% to 100%
            
            // Fade renderer canvas
            renderer.domElement.style.transition = 'opacity 0.5s ease';
            renderer.domElement.style.opacity = String(1 - fadeAmount * 0.8); // Keep slight visibility
        }
        
        // Keep stars visible over the gradient longer
        if (progress > 0.7) {
            const starFade = (progress - 0.7) / 0.3;
            textCanvas.style.opacity = String(1 - starFade);
        }
    }
    
    // Render star particles
    function renderStars() {
        if (starParticles.length === 0) return;
        
        const now = Date.now();
        
        // Update and render each star
        for (let i = starParticles.length - 1; i >= 0; i--) {
            const star = starParticles[i];
            
            // Update position based on velocity
            if (star.vx !== undefined) {
                star.x += star.vx;
                star.y += star.vy;
                star.z += star.vz;
                
                // Very slow drag to keep stars moving
                star.vx *= 0.995;
                star.vy *= 0.995;
                star.vz *= 0.995;
            }
            
            // Calculate age and fade
            const age = (now - star.birthTime) / 1000; // in seconds
            const fadeDuration = 8; // fade over 8 seconds (much slower)
            const fadeProgress = Math.min(1, age / fadeDuration);
            
            // Dim brightness over time - keep them bright longer
            star.brightness = 1 - fadeProgress * 0.5; // Keep 50% minimum
            
            // Update twinkle
            star.twinkle += star.twinkleSpeed * 0.016;
            const twinkleBrightness = 0.8 + Math.sin(star.twinkle) * 0.2;
            const finalBrightness = star.brightness * twinkleBrightness;
            
            // Keep stars visible much longer - only remove when very faint
            if (finalBrightness < 0.05) {
                starParticles.splice(i, 1);
                continue;
            }
            
            // Project to screen space
            const vector = new THREE.Vector3(star.x, star.y, star.z);
            vector.project(camera);
            
            // Check if behind camera
            if (vector.z > 1) continue;
            
            const x = (vector.x + 1) / 2 * window.innerWidth;
            const y = (-vector.y + 1) / 2 * window.innerHeight;
            
            // Size based on distance (z-depth)
            const depthScale = Math.max(0.5, 1 - vector.z * 0.5);
            const renderSize = star.size * window.innerWidth * 0.01 * depthScale;
            
            // Draw voxel as square with slight glow
            const voxelSize = renderSize * 1.5;
            const glowSize = voxelSize * 1.5;
            
            // Outer glow
            const gradient = textCtx.createRadialGradient(x, y, 0, x, y, glowSize);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${finalBrightness * 0.8})`);
            gradient.addColorStop(0.6, `rgba(255, 255, 255, ${finalBrightness * 0.3})`);
            gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
            textCtx.fillStyle = gradient;
            textCtx.beginPath();
            textCtx.arc(x, y, glowSize, 0, Math.PI * 2);
            textCtx.fill();
            
            // Core voxel - square shape
            textCtx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, finalBrightness * 1.1)})`;
            textCtx.fillRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);
            
            // Subtle border for voxel definition
            if (finalBrightness > 0.5) {
                textCtx.strokeStyle = `rgba(255, 255, 255, ${finalBrightness * 0.6})`;
                textCtx.lineWidth = 0.5;
                textCtx.strokeRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);
            }
        }
    }

    // --- Play button wiring -------------------------------------------------
    const playOverlay = document.getElementById('play');
    const playBtn = document.getElementById('playBtn');
    const skipBtn = document.getElementById('skipBtn');
    
    playBtn.addEventListener('click', ()=>{
      running = true; clock.getDelta();
      playOverlay.classList.add('hidden');
      skipBtn.classList.remove('hidden'); // Show skip button
      clearToast();
      frame();
    });
    
    // --- Skip button logic ---------------------------------------------------
    skipBtn.addEventListener('click', () => {
      if (!running) return;

      // Jump to CELLI phase
      totalTime = introCfg.celliEnd - 6.0; // Start 6 seconds before celli ends (during trickle/chime)
      
      // Hide all prior elements
      quoteEl.style.visibility = 'hidden';
      quoteEl.style.opacity = '0';
      loomworksEl.style.display = 'none';
      triMesh.visible = false;
      blackHole.visible = false;
      spheres.forEach(s => s.visible = false);
      
      // Setup CELLI
      if (!celliStarted) {
        celliStarted = true;
        celliStartTime = totalTime;
      }
      
      // Don't hide skip button - it will transform into a bow later
      
      // Play startup bass note
      setTimeout(() => {
        playStartupBass();
      }, 500);
    });

    skipBtn.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        skipBtn.click();
      }
    });

    // --- Bring-up Self‑Tests & Toast ---------------------------------------
    (function bootDiagnostics(){
      const meshes = scene.children.filter(o=>o.isMesh).length;
      const lines = [ `Meshes: ${meshes}`, `Hint: press Play to start animation` ];
      toast(lines,'ok');
      if(meshes!==5) toast([`Expected 5 meshes (3 spheres + 1 hole + 1 tri), got ${meshes}`],'warn');
    })();
  </script>
</body>
</html>
