<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Tri‑Trail Evolved • three.js</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@100;300&display=swap" rel="stylesheet">
  <style>
    :root { --bg: #000; --fg: #e6e6e6; --accent:#8ab4ff; }
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    #app { position:fixed; inset:0; background:var(--bg); }
    .hud { position:fixed; inset:0; pointer-events:none; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .brand { position:absolute; left:2rem; bottom:2rem; color:var(--fg); letter-spacing:0.08em; font-weight:600; font-size:12px; opacity:.65; text-transform:uppercase; }
    .quote { position:absolute; left:50%; top:50%; transform:translate(-50%, -50%); color:var(--fg); font-weight:300; font-size:16px; letter-spacing:0.03em; line-height:1.6; max-width:560px; width:90%; text-align:center; font-style:italic; margin:0; padding:0 20px; box-sizing:border-box; z-index:10; visibility:hidden; opacity:0; transition: color 0.45s ease, text-shadow 0.45s ease; display:grid; grid-template-columns:1fr auto 1fr; align-items:center; justify-items:center; gap:0.45em; }
    .quote__text { display:block; max-width:100%; }
    .quote__text--before { grid-column:1; justify-self:end; text-align:right; }
    .quote__text--after { grid-column:3; justify-self:start; text-align:left; }
    .quote__lookWrap { grid-column:2; position:relative; display:inline-flex; align-items:center; justify-content:center; min-width:3.5ch; transition:opacity 0.4s ease, transform 0.4s ease; }
    .quote.quote--no-look { grid-template-columns:1fr; }
    .quote.quote--no-look .quote__text--before { grid-column:1; justify-self:center; text-align:center; }
    .quote.quote--no-look .quote__text--after { display:none; }
    .quote__lookWrap::before { content:""; position:absolute; inset:-0.15em -0.35em; border-radius:4px; background:rgba(138,180,255,0.08); opacity:0; transition:opacity 0.3s ease; }
    .quote.scrambling .quote__lookWrap::before { opacity:1; }
    .quote__lookWrap.quote__lookWrap--hidden { opacity:0; transform:translateY(0.45em); pointer-events:none; min-width:0; width:0; margin:0; }
    .quote__look { font-family:'Roboto Mono', ui-monospace, monospace; font-style:normal; letter-spacing:0.12em; text-transform:uppercase; }
    .look-k-floater { position:fixed; left:0; top:0; transform:translate(-50%, -50%); pointer-events:none; font-family:'Roboto Mono', ui-monospace, monospace; font-size:16px; letter-spacing:0.12em; text-transform:uppercase; color:#e6e6e6; text-shadow:0 0 12px rgba(138,180,255,0.6); opacity:0; transition: transform 0.75s cubic-bezier(0.23, 1, 0.32, 1), opacity 0.35s ease; z-index:15; }
    .quote.quote--loom { font-family:'Roboto Mono', ui-monospace, monospace; font-style:normal; letter-spacing:0.12em; }
    .quote.visible { animation: fadeInQuote 3s ease-out forwards; display:block !important; visibility:visible; }
    @keyframes fadeInQuote {
      0% { opacity:0; transform:translate(-50%, -50%) translateY(20px); }
      100% { opacity:.85; transform:translate(-50%, -50%) translateY(0); }
    }
    .quote.glitch { animation: glitchText 0.5s ease-in-out infinite; }
    .quote.scrambling { text-shadow: 0 0 18px rgba(138, 180, 255, 0.4); color:#f5f5f5; }
    @keyframes glitchText {
      0%, 100% { opacity:.85; transform:translate(-50%, -50%) translateX(0); text-shadow: 0 0 0 transparent; }
      10% { opacity:.8; transform:translate(-50%, -50%) translateX(-1px); text-shadow: 1px 0 #ff1e6e, -1px 0 #00a8ff; }
      20% { opacity:.9; transform:translate(-50%, -50%) translateX(1px); text-shadow: -1px 0 #ffb62e, 1px 0 #00a8ff; }
      30% { opacity:.85; transform:translate(-50%, -50%) translateX(0); text-shadow: 0 0 0 transparent; }
    }
    .quote.glitchMedium { animation: glitchMedium 0.3s ease-in-out infinite; }
    @keyframes glitchMedium {
      0%, 100% { opacity:.82; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
      15% { opacity:.7; transform:translate(-50%, -50%) translateX(-3px) translateY(1px); text-shadow: 2px 0 #ff1e6e, -2px 0 #00a8ff; }
      35% { opacity:.8; transform:translate(-50%, -50%) translateX(3px) translateY(-2px); text-shadow: -3px 0 #ffb62e, 3px 0 #00a8ff; }
      55% { opacity:.75; transform:translate(-50%, -50%) translateX(-2px) translateY(2px); text-shadow: 2px 0 #00a8ff, -2px 0 #ff1e6e; }
      75% { opacity:.78; transform:translate(-50%, -50%) translateX(2px) translateY(-1px); text-shadow: -2px 0 #ffb62e, 2px 0 #ff1e6e; }
    }
    .quote.glitchIntense { animation: glitchIntense 0.12s ease-in-out infinite; }
    @keyframes glitchIntense {
      0% { opacity:.75; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
      12% { opacity:.5; transform:translate(-50%, -50%) translateX(-8px) translateY(4px); text-shadow: 4px 0 #ff1e6e, -4px 0 #00a8ff, 0 4px #ffb62e; }
      25% { opacity:.7; transform:translate(-50%, -50%) translateX(6px) translateY(-6px); text-shadow: -6px 0 #ffb62e, 6px 0 #00a8ff, 0 -6px #ff1e6e; }
      40% { opacity:.45; transform:translate(-50%, -50%) translateX(-10px) translateY(8px); text-shadow: 8px 0 #00a8ff, -8px 0 #ff1e6e; }
      55% { opacity:.65; transform:translate(-50%, -50%) translateX(5px) translateY(-3px); text-shadow: -5px 0 #ffb62e, 5px 0 #ff1e6e; }
      70% { opacity:.55; transform:translate(-50%, -50%) translateX(-7px) translateY(5px); text-shadow: 6px 0 #00a8ff, -5px 0 #ffb62e; }
      85% { opacity:.6; transform:translate(-50%, -50%) translateX(8px) translateY(-4px); text-shadow: -7px 0 #ff1e6e, 6px 0 #00a8ff; }
      100% { opacity:.5; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
    }
    .loomworks { position:absolute; left:50%; top:50%; transform:translate(calc(-50% + var(--loomOffsetX, 0px)), calc(-50% + var(--loomOffsetY, 0px))); color:#fff; font-weight:300; font-size:20px; letter-spacing:0.15em; opacity:0; text-align:center; pointer-events:none; font-family:'Roboto Mono', ui-monospace, monospace; white-space:nowrap; }
    .loomworks.visible { animation: fadeInLoom 2s ease-out forwards; }
    .loomworks-chunk { display:inline-block; padding:0 0.08em; opacity:0; transform:translateY(12px); transition: opacity 0.45s ease, transform 0.45s ease, background 0.25s ease, color 0.25s ease; }
    .loomworks.visible .loomworks-chunk { opacity:1; transform:translateY(0); }
    .loomworks-chunk.selected { background:#fff; color:#000; box-shadow:0 0 0 1px rgba(0,0,0,0.55); }
    .loomworks-chunk.shift-right { transform:translateX(0.35em); }
    #loomTail { white-space:pre; }
    @keyframes fadeInLoom {
      0% { opacity:0; transform:translate(-50%, -50%) scale(0.95); }
      100% { opacity:1; transform:translate(-50%, -50%) scale(1); }
    }
    
    /* Doorway portal - starts as vertical bar */
    .doorway { position:fixed; left:50%; bottom:20%; transform:translate(-50%, 0); width:4px; height:60px; background:#fff; pointer-events:none; z-index:20; opacity:0; box-shadow: 0 0 15px 5px rgba(255,255,255,0.8), 0 0 30px 10px rgba(255,255,255,0.5); transition: width 1.5s cubic-bezier(0.4, 0, 0.2, 1), height 1.5s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 1.5s ease-out, opacity 0.5s ease-out; overflow:hidden; }
    .doorway.visible { opacity:1; }
    .doorway.open { width:min(280px, 85vw); height:80px; box-shadow: 0 0 40px 20px rgba(255,255,255,0.7), 0 0 80px 35px rgba(255,255,255,0.4), inset 0 0 60px rgba(255,255,255,0.6); }
    
    /* Light rays emanating from doorway - forward emission only (cut off at top) */
    .doorway::before { content:""; position:absolute; left:-150%; right:-150%; top:0%; bottom:-200%; background:radial-gradient(ellipse 120% 80% at center top, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.15) 40%, transparent 70%); opacity:0; transition:opacity 1.5s ease-out; pointer-events:none; clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); }
    .doorway.open::before { opacity:1; }
    
    /* Input prompt inside doorway */
    .prompt-container { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; opacity:0; transition:opacity 1s ease-in 1.5s; pointer-events:none; user-select:none; -webkit-user-select:none; }
    .doorway.open .prompt-container { opacity:1; pointer-events:auto; cursor:text; }
    .prompt { 
      position: relative;
      font-family: 'Roboto Mono', ui-monospace, monospace; 
      font-size: clamp(12px, 3.5vw, 36px);
      font-weight:100; 
      color:#000; 
      letter-spacing:0.08em;
      z-index: 2;
      white-space: nowrap;
    }
    /* Shadow trick - vertically flipped and stretched text acting as shadow */
    .prompt::after {
      content: attr(data-text);
      position: absolute;
      left: 0;
      top: 130%;
      width: 100%;
      font-family: 'Roboto Mono', ui-monospace, monospace; 
      font-size: clamp(12px, 3.5vw, 36px);
      font-weight: 100;
      color: rgba(0, 0, 0, 0.95);
      letter-spacing: 0.08em;
      transform: scaleY(-1.4) perspective(150px) rotateX(68deg);
      transform-origin: top center;
      opacity: 0.9;
      filter: blur(1px);
      z-index: 1;
      pointer-events: none;
      white-space: nowrap;
      mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.7) 35%, rgba(0,0,0,0) 100%);
      -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.7) 35%, rgba(0,0,0,0) 100%);
    }
    .cursor { animation:blink 1s step-end infinite; }
    @keyframes blink {
      0%, 50% { opacity:1; }
      51%, 100% { opacity:0; }
    }
    
    /* CELLI glitch effects */
    .celli-glitch .char { display:inline-block; transition:opacity 0.1s; }
    .celli-glitch .char.flicker { animation:celliFlicker 0.15s infinite; }
    .celli-glitch .char.hidden { opacity:0; }
    @keyframes celliFlicker {
      0%, 100% { opacity:1; text-shadow: 0 0 8px currentColor; }
      25% { opacity:0.3; transform:translateX(-2px); }
      50% { opacity:0.6; transform:translateX(2px); }
      75% { opacity:0.2; transform:translateY(-1px); }
    }
    .screenGlitch { position:fixed; inset:0; pointer-events:none; background:#000; opacity:0; z-index:5; mix-blend-mode:normal; }
    .screenGlitch.active { animation: screenFlicker 0.2s infinite; }
    @keyframes screenFlicker {
      0%, 100% { opacity:0; background:#000; }
      15% { opacity:0.08; background:#fff; }
      30% { opacity:0; background:#000; }
      45% { opacity:0.12; background:#00a8ff; }
      60% { opacity:0; background:#000; }
      80% { opacity:0.1; background:#ff1e6e; }
    }
    .fallback { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; color:#bbb; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
    .scanlines::before { content:""; position:absolute; inset:0; pointer-events:none; background: repeating-linear-gradient( to bottom, rgba(255,255,255,0.04), rgba(255,255,255,0.04) 1px, transparent 1px, transparent 3px ); mix-blend-mode: overlay; opacity:.18; transition: opacity 1s ease; }
    .scanlines.fade-scanlines::before { opacity: 0; }
    .vignette { position:absolute; inset:0; pointer-events:none; box-shadow: inset 0 0 240px rgba(0,0,0,.75), inset 0 0 800px rgba(0,0,0,.65); }
    canvas { filter: saturate(1.06) contrast(1.06) brightness(1.02); display:block; }

    /* Play overlay */
    .play { position:fixed; inset:0; display:grid; place-items:center; background: radial-gradient(ellipse at center, rgba(30,30,30,.6) 0%, rgba(0,0,0,.9) 60%); z-index:10; }
    .play.hidden{ display:none; }
    .play button{ pointer-events:auto; appearance:none; border:none; padding:14px 20px; border-radius:999px; font-weight:700; letter-spacing:.06em; text-transform:uppercase; background:#111; color:#e8eaed; box-shadow: 0 0 0 2px rgba(255,255,255,.08) inset, 0 6px 20px rgba(0,0,0,.45); cursor:pointer; display:flex; gap:12px; align-items:center; }
    .play button::before{ content:"▶"; font-size:14px; opacity:.9; }

    /* Debug toast */
    .toast{ position:fixed; right:14px; top:14px; background:rgba(18,18,18,.9); color:#cbd5e1; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:10px 12px; font: 12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; z-index: 9; box-shadow: 0 10px 24px rgba(0,0,0,.35); pointer-events:none; opacity:.95; max-width: 42ch; }
    .toast strong{ color:#fff; font-weight:700; }
    .toast .ok{ color:#9ae6b4; }
    .toast .warn{ color:#f6e05e; }
    .toast .err{ color:#feb2b2; }
  </style>
</head>
<body>
  <div id="app" class="scanlines"></div>
  <div class="hud">
    <div id="quote" class="quote quote--no-look">
      <span id="quoteBefore" class="quote__text quote__text--before">...if you GAZE for long into an abyss, the abyss GAZES also into you.</span>
      <span id="quoteLookWrap" class="quote__lookWrap quote__lookWrap--hidden"><span id="quoteLook" class="quote__look">LOOK</span></span>
      <span id="quoteAfter" class="quote__text quote__text--after"></span>
    </div>
    <div id="loomworks" class="loomworks" aria-live="polite">
      <span id="loomPre" class="loomworks-chunk">L</span><span id="loomCore" class="loomworks-chunk">OO</span><span id="loomPost" class="loomworks-chunk">K</span><span id="loomTail" class="loomworks-chunk"></span>
    </div>
    <div class="vignette"></div>
  </div>
  <div id="screenGlitch" class="screenGlitch"></div>
  
  <!-- Doorway portal -->
  <div id="doorway" class="doorway">
    <div class="prompt-container">
      <div class="prompt" data-text="=STAR_"><span id="promptText">=STAR</span><span id="promptCursor" class="cursor">_</span></div>
    </div>
  </div>
  
  <!-- Hidden input for mobile keyboard -->
  <input id="hiddenInput" type="text" style="position:absolute; left:-9999px; opacity:0;" autocomplete="off" />
  
  <audio id="chime" preload="auto">
    <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=" type="audio/wav">
  </audio>
  <div id="fallback" class="fallback" style="display:none">⚠️ WebGL unavailable or ES Modules not supported. Try a newer browser/GPU.</div>

  <div id="play" class="play"><button id="playBtn">Play</button></div>
  <div id="toast" class="toast" style="display:none"></div>

  <!-- Import map so bare specifiers resolve to CDN modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    // --- Imports ------------------------------------------------------------
    import * as THREE from "three";
    import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
    import { AfterimagePass } from "three/examples/jsm/postprocessing/AfterimagePass.js";
    import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
    import { RoundedBoxGeometry } from "three/examples/jsm/geometries/RoundedBoxGeometry.js";

    // --- Debug helpers ------------------------------------------------------
    const toastEl = document.getElementById('toast');
    function toast(lines, level='ok'){
      const arr = Array.isArray(lines) ? lines : [String(lines)];
      toastEl.innerHTML = `<strong>Debug</strong><br>${arr.map(l=>`<span class="${level}">${l}</span>`).join('<br>')}`;
      toastEl.style.display='block';
    }
    function clearToast(){ toastEl.style.display='none'; }

    // --- WebGL capability check --------------------------------------------
    const hasWebGL = (() => { try { const c = document.createElement('canvas'); return !!(window.WebGLRenderingContext && (c.getContext('webgl2')||c.getContext('webgl')||c.getContext('experimental-webgl'))); } catch(e){ return false; } })();
    if (!hasWebGL) { document.getElementById('fallback').style.display = 'flex'; throw new Error('WebGL not available'); }

    // --- Core setup ---------------------------------------------------------
    const app = document.getElementById('app');
    const quoteEl = document.getElementById('quote');
    const quoteBefore = document.getElementById('quoteBefore');
    const quoteAfter = document.getElementById('quoteAfter');
    const quoteLook = document.getElementById('quoteLook');
    const quoteLookWrap = document.getElementById('quoteLookWrap');
    const loomworksEl = document.getElementById('loomworks');
    const loomPre = document.getElementById('loomPre');
    const loomCore = document.getElementById('loomCore');
    const loomPost = document.getElementById('loomPost');
    const loomTail = document.getElementById('loomTail');
    const quoteStates = {
        initial: {
            before: '...if you GAZE for long into an abyss, the abyss GAZES also into you.',
            after: '',
            look: 'LOOK',
            showLook: false
        },
        look: {
            before: '...if you ',
            after: ' for long into an abyss, the abyss LOOKS also into you.',
            look: 'LOOK',
            showLook: true
        },
        despair: {
            before: '',
            after: ' on my works, ye Mighty, and despair!',
            look: 'LOOK',
            showLook: true
        }
    };
    let lookAnchorPosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

    applyQuoteState(quoteStates.initial, { immediate: true });
    quoteEl.classList.remove('quote--loom');
    loomTail.textContent = '';
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.setClearColor(0x000000, 1);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 10);
    camera.position.set(0, 0, 2);
    camera.lookAt(0, 0, 0);

     const blackHoleGeo = new THREE.CircleGeometry(0.35, 64);
    const blackHoleMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 }, pulseFactor: { value: 0.5 } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `
            varying vec2 vUv; uniform float time; uniform float pulseFactor;
            void main() {
                vec2 center = vec2(0.5);
                float dist = distance(vUv, center);
                 // Organic pulsing with multiple harmonics
                 float baseRadius = 0.08 + pulseFactor * 0.28;
                 float pulse1 = 0.015 * sin(time * 3.5);
                 float pulse2 = 0.008 * sin(time * 7.3 + 1.5);
                 float radius = baseRadius + pulse1 + pulse2;
                 // Ultra-soft gradient fade for dreamy quality
                 float fadeDistance = radius * 1.6;
                float alpha = 1.0 - smoothstep(radius - fadeDistance, radius, dist);
                 // Softer alpha curve with slight glow at edges
                 alpha = pow(alpha, 0.6) * 0.9;
                 gl_FragColor = vec4(0.0, 0.0, 0.0, alpha);
            }
        `,
        transparent: true, depthWrite: false
    });
    const blackHole = new THREE.Mesh(blackHoleGeo, blackHoleMat);
    blackHole.position.z = 0.1;
    scene.add(blackHole);

    const R = 0.16;
    const makeMat = (hex) => new THREE.MeshBasicMaterial({ color: new THREE.Color(hex), blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
    const CYAN = 0x00a8ff, MAGENTA = 0xff1e6e, YELLOW = 0xffb62e;
    const colors = [new THREE.Color(CYAN), new THREE.Color(YELLOW), new THREE.Color(MAGENTA)];
    const pulseBaseColor = new THREE.Color(0xffd95a);
    const pulseHighlightColor = new THREE.Color(0xfff4a0);
    const pulseEdgeColor = new THREE.Color(0xfff7c4);
    
    // Create custom rounded shapes: square (cyan), triangle (yellow), circle (magenta)
    
    // Shape 0: Rounded Square (Blue/Cyan)
    const createRoundedSquare = (size, radius) => {
        const shape = new THREE.Shape();
        const r = radius;
        const s = size / 2;
        shape.moveTo(-s + r, -s);
        shape.lineTo(s - r, -s);
        shape.quadraticCurveTo(s, -s, s, -s + r);
        shape.lineTo(s, s - r);
        shape.quadraticCurveTo(s, s, s - r, s);
        shape.lineTo(-s + r, s);
        shape.quadraticCurveTo(-s, s, -s, s - r);
        shape.lineTo(-s, -s + r);
        shape.quadraticCurveTo(-s, -s, -s + r, -s);
        return new THREE.ShapeGeometry(shape, 32);
    };
    
    // Shape 1: Rounded Triangle (Yellow) - flat bottom, pointing up
    const createRoundedTriangle = (size, radius) => {
        const shape = new THREE.Shape();
        const h = size * Math.sqrt(3) / 2; // Equilateral triangle height
        
        // Three vertices of equilateral triangle with FLAT BOTTOM
        const top = { x: 0, y: h / 2 };              // Top vertex (pointing up)
        const bl = { x: -size/2, y: -h / 2 };        // Bottom left
        const br = { x: size/2, y: -h / 2 };         // Bottom right
        
        const r = radius * 0.8; // Smaller radius for cleaner corners
        
        // Start at bottom-left, move clockwise
        shape.moveTo(bl.x + r, bl.y);
        
        // Bottom edge to bottom-right
        shape.lineTo(br.x - r, br.y);
        
        // Curve around bottom-right corner
        shape.quadraticCurveTo(br.x, br.y, br.x - r * 0.5, br.y + r * 0.866);
        
        // Right edge going up to top
        shape.lineTo(top.x + r * 0.5, top.y - r * 0.866);
        
        // Curve around top corner
        shape.quadraticCurveTo(top.x, top.y, top.x - r * 0.5, top.y - r * 0.866);
        
        // Left edge going down to bottom-left
        shape.lineTo(bl.x + r * 0.5, bl.y + r * 0.866);
        
        // Curve around bottom-left corner
        shape.quadraticCurveTo(bl.x, bl.y, bl.x + r, bl.y);
        
        return new THREE.ShapeGeometry(shape, 32);
    };
    
    // Shape 2: Circle (Pink/Magenta)
    const createCircle = (radius) => {
        return new THREE.CircleGeometry(radius, 64);
    };
    
    const geoSquare = createRoundedSquare(R * 2, R * 0.3);
    const geoTriangle = createRoundedTriangle(R * 2, R * 0.35);
    const geoCircle = createCircle(R);
    
    // Store original geometries for morphing
    const originalGeos = [geoSquare, geoTriangle, geoCircle];
    
    // Create circle targets for morphing (all shapes will become circles)
    const circleGeoTarget = createCircle(R);
    
    const spheres = [
        new THREE.Mesh(geoSquare, makeMat(CYAN)),
        new THREE.Mesh(geoTriangle, makeMat(YELLOW)),
        new THREE.Mesh(geoCircle, makeMat(MAGENTA))
    ];
    spheres.forEach((s,i)=>{ s.position.z = -i*0.002; scene.add(s); });

    // --- Voxel System for CELLI ---
    const voxelSize = 0.08;
    const voxelGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
    const roundedVoxelGeo = new RoundedBoxGeometry(voxelSize, voxelSize, voxelSize, 4, voxelSize * 0.35);
    const voxelMat = new THREE.MeshBasicMaterial({
        color: 0x444444,  // Start as dim gray
        transparent: true, 
        opacity: 0,
        blending: THREE.NormalBlending  // Normal blending for borders
    });
    
    // Create edges geometry for borders
    const edgesGeo = new THREE.EdgesGeometry(voxelGeo);
    const edgeMat = new THREE.LineBasicMaterial({ 
        color: 0x888888,
        transparent: true,
        opacity: 0
    });
    
    // CELLI letter patterns (5x5 grid for each letter)
    const celliPatterns = {
        C: [[0,1,1,1,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [0,1,1,1,0]],
        E: [[1,1,1,1,1], [1,0,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,1,1,1]],
        L: [[1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [1,1,1,1,1]],
        I: [[1,1,1,1,1], [0,0,1,0,0], [0,0,1,0,0], [0,0,1,0,0], [1,1,1,1,1]]
    };
    
    const voxels = [];
    const letters = ['C', 'E', 'L', 'L', 'I'];
    let letterSpacing = 0.6;
    let celliScale = 1.0;
    
    // Responsive scaling for touch devices
    function calculateCelliScale() {
        const aspect = window.innerWidth / window.innerHeight;
        
        // Calculate total width needed for all letters (including padding)
        const totalBaseWidth = letters.length * letterSpacing;
        
        // Camera view width in world units
        let viewWidth;
        if (aspect > 1) {
            // Landscape
            viewWidth = aspect * 2;
        } else {
            // Portrait
            viewWidth = 2;
        }
        
        // Scale to fit 85% of view width
        const targetWidth = viewWidth * 0.85;
        if (totalBaseWidth > targetWidth) {
            celliScale = targetWidth / totalBaseWidth;
        } else {
            celliScale = 1.0;
        }
    }
    calculateCelliScale();
    
    const startX = -(letters.length * letterSpacing * celliScale) / 2 + (letterSpacing * celliScale) / 2;
    
    letters.forEach((letter, letterIdx) => {
        const pattern = celliPatterns[letter];
        const letterX = startX + letterIdx * letterSpacing * celliScale;
        
        pattern.forEach((row, rowIdx) => {
            row.forEach((cell, colIdx) => {
                if (cell === 1) {
                    // Create voxel with border
                    const voxel = new THREE.Mesh(voxelGeo, voxelMat.clone());
                    const edges = new THREE.LineSegments(edgesGeo, edgeMat.clone());
                    voxel.add(edges);
                    
                    const x = letterX + (colIdx - 2) * voxelSize * 1.2 * celliScale;
                    const y = (2 - rowIdx) * voxelSize * 1.2 * celliScale + 0.35; // Offset up
                    
                    voxel.userData = {
                        targetX: x,
                        targetY: y,
                        startY: y + 2.0 + Math.random() * 1.0,
                        dropDelay: letterIdx * 0.15 + (rowIdx * colIdx) * 0.02,
                        dropSpeed: 0.02 + Math.random() * 0.01,
                        settled: false,
                        jigglePhase: Math.random() * Math.PI * 2,
                        flickerPhase: Math.random() * Math.PI * 2,
                        edges: edges,  // Store reference to edges
                        gridX: letterIdx,  // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)
                        gridY: rowIdx,     // Row index (0=top, 4=bottom)
                        gridCol: colIdx,   // Column index within letter (0-4)
                        glitched: false,    // Track if this voxel has been glitched out
                        baseScale: celliScale,  // Store scale for proper sizing
                        originalMaterial: voxel.material,
                        originalEdgesMaterial: edges.material,
                        pulseMaterial: null,
                        pulsePhaseOffset: Math.random() * Math.PI * 2
                    };
                    
                    // Scale voxel size to match the overall scale
                    voxel.scale.set(celliScale, celliScale, celliScale);
                    
                    voxel.position.set(x, voxel.userData.startY, 0);
                    voxel.visible = false;
                    scene.add(voxel);
                    voxels.push(voxel);
                }
            });
        });
    });

    // --- [NEW] Shader for the color triangle between spheres ---
    const triGeo = new THREE.PlaneGeometry(4, 4); // Covers view
    const triMat = new THREE.ShaderMaterial({
        uniforms: {
            points: { value: [new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()] },
            colors: { value: colors },
            aspect: { value: 1.0 }
        },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
        fragmentShader: `
            varying vec2 vUv;
            uniform vec2 points[3];
            uniform vec3 colors[3];
            uniform float aspect;

            // Function to calculate barycentric coordinates
            vec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c) {
                vec2 v0 = b - a, v1 = c - a, v2 = p - a;
                float d00 = dot(v0, v0);
                float d01 = dot(v0, v1);
                float d11 = dot(v1, v1);
                float d20 = dot(v2, v0);
                float d21 = dot(v2, v1);
                float denom = d00 * d11 - d01 * d01;
                float v = (d11 * d20 - d01 * d21) / denom;
                float w = (d00 * d21 - d01 * d20) / denom;
                float u = 1.0 - v - w;
                return vec3(u, v, w);
            }

            void main() {
                // Adjust UVs to be centered and handle aspect ratio
                vec2 p = (vUv - 0.5) * 2.0;
                p.x *= aspect;

                vec3 b = barycentric(p, points[0], points[1], points[2]);

                if (b.x >= 0.0 && b.y >= 0.0 && b.z >= 0.0) {
                    // We are inside the triangle
                    vec3 color = b.x * colors[0] + b.y * colors[1] + b.z * colors[2];
                    
                     // More defined edges with softer interior
                     float edgeDist = min(b.x, min(b.y, b.z));
                     float edgeFade = smoothstep(0.0, 0.2, edgeDist);
                     
                     // Distance-based fading
                     float centerDist = length(p);
                     float centerFade = 1.0 - smoothstep(0.15, 0.65, centerDist);
                     centerFade = pow(centerFade, 0.6);
                     
                     // Subtle center glow
                     float centerGlow = 1.0 - smoothstep(0.0, 0.25, centerDist);
                     float finalAlpha = (edgeFade * centerFade + centerGlow * 0.12) * 0.55;
                     
                     gl_FragColor = vec4(color, finalAlpha);
                } else {
                    discard;
                }
            }
        `,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const triMesh = new THREE.Mesh(triGeo, triMat);
    triMesh.position.z = -0.1; // Behind spheres
    triMesh.material.opacity = 0;
    scene.add(triMesh);

    // --- Composer & passes --------------------------------------------------
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.9, 0.2);
    composer.addPass(bloomPass);
    const afterimagePass = new AfterimagePass(0.96);
    composer.addPass(afterimagePass);
    const filmPass = new ShaderPass({
      uniforms: { tDiffuse: { value: null }, time: { value: 0 }, noise: { value: 0.03 }, scanAmp: { value: 0.03 } },
      vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader: `
        precision highp float; varying vec2 vUv; uniform sampler2D tDiffuse; uniform float time; uniform float noise; uniform float scanAmp;
        float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
        void main(){ vec3 col = texture2D(tDiffuse, vUv).rgb; float n = rand(vUv + fract(time)); float scan = sin((vUv.y + time*0.04)*3.14159*480.0) * scanAmp; col += n*noise; col += scan; col = pow(col, vec3(1.02)); gl_FragColor = vec4(col, 1.0); }`
    });
    composer.addPass(filmPass);

    // --- [REWRITTEN] Eclipse & Radiate Motion with Intro Sequence ----------
    const motionCfg = {
        speed: 0.8,
        maxDist: 0.65,
        rotationSpeed: 0.4,
        minScale: 0.4
    };

    // Intro sequence with magical progression
    const introCfg = {
        rollEnd: 2.5,        // Roll into place (slower)
        bounceEnd: 4.5,      // Sequential bounces
        triangleEnd: 7.5,    // Form triangle + grow + converge
        transitionEnd: 9.5,  // Transition to orbit
        normalEnd: 21.5,     // Normal animation duration (about 3 loops)
        vennEnd: 24.0,       // Clear venn diagram
        collapseEnd: 28.0,   // Collapse to white circle (extended)
        glitchEnd: 30.5,     // Intense glitch + fade (extended)
        blackoutEnd: 32.0,   // Complete blackout
        loomworksEnd: 36.0,  // Show Loomworks text
        celliEnd: 42.0,      // CELLI voxel animation
        doorwayEnd: 50.0,    // Doorway portal sequence
        ballSize: 0.12,      // Size during intro
        bounceHeight: 0.35,  // Bounce amplitude
        bounceDuration: 0.6  // Each bounce duration
    };
    
    // Audio context for synth and chime
    let audioCtx = null;
    let synthGain = null;
    let synthOsc1 = null;
    let synthOsc2 = null;
    let synthOsc3 = null;
    let landingSounds = [false, false, false]; // Track if shape has landed
    let lastThunkTime = [0, 0, 0]; // Track last thunk time for each shape
    
    let quoteShown = false;
    let quoteLookSwapped = false;
    let quoteDespairShown = false;
    let glitchStarted = false;
    let mediumGlitchStarted = false;
    let intenseGlitchStarted = false;
    let screenGlitchStarted = false;
    let blackoutStarted = false;
    let loomworksShown = false;
    let loomworksRevealStarted = false;
    let lookKSlideStarted = false;
    let lookKSlidePromise = null;
    let chimePlayed = false;
    let celliStarted = false;
    let doorwayShown = false;
    let doorwayOpened = false;
    let inputAttempted = false;
    let celliGlitchStarted = false;
    let finalRollRotations = [0, 0, 0]; // Store final rotations from roll phase
    const basePromptText = '=STAR';
    let inputText = basePromptText;
    let tEntered = false;
    let burstAnimStarted = false;
    const starParticles = []; // Stars from burst voxels
    let loomworksTypingTimeout = null;
    let backspaceEffectState = 'idle';
    let backspaceEffectStart = 0;
    let backspacePulseStart = 0;
    let backspaceEffectVoxel = null;
    
    // Text particle system for click interactions
    const textParticles = [];
    const manicTexts = ["huh?", "who's there?", "AH!", "HAHA.", "ow.", "ahh...", "oh!", "what?", "why?", "where?", "when?"];
    const timeTexts = () => {
        const formats = [
            new Date().toLocaleTimeString(),
            new Date().toLocaleDateString(),
            `${new Date().getHours()}:${String(new Date().getMinutes()).padStart(2,'0')}`,
            new Date().getFullYear().toString(),
            `${Math.floor(Date.now()/1000)}`,
            new Date().toISOString().split('T')[0]
        ];
        return formats[Math.floor(Math.random() * formats.length)];
    };
    const equationTexts = [
        "x²+y²=r²", "∫f(x)dx", "E=mc²", "∂f/∂x", "Σ(x)", "√(a²+b²)",
        "(0,0)", "(x,y,z)", "[1,2,3]", "θ=arctan(y/x)", "∇×F", "dy/dx"
    ];

    const glitchGlyphs = "!<>-_\\/[]{}—=+*^?#▒▓█▞▚";

    function captureLookAnchorPosition() {
        if (!quoteLookWrap) return;
        const rect = quoteLookWrap.getBoundingClientRect();
        if (!rect.width && !rect.height) return;
        lookAnchorPosition = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
        };
        updateLoomworksOffset();
    }

    function updateLoomworksOffset() {
        const offsetX = lookAnchorPosition.x - window.innerWidth / 2;
        const offsetY = lookAnchorPosition.y - window.innerHeight / 2;
        loomworksEl.style.setProperty('--loomOffsetX', `${offsetX}px`);
        loomworksEl.style.setProperty('--loomOffsetY', `${offsetY}px`);
    }

    function glitchSwapQuote(targetState, { duration = 1100, onComplete = null } = {}) {
        if (!targetState) return;
        if (quoteEl.dataset.swapping === '1') return;

        quoteEl.dataset.swapping = '1';
        quoteEl.classList.add('scrambling');

        const initialBefore = quoteBefore.textContent || '';
        const initialAfter = quoteAfter.textContent || '';
        const targetBefore = targetState.before || '';
        const targetAfter = targetState.after || '';
        const targetLook = targetState.look || quoteLook.textContent || '';
        const beforeMax = Math.max(initialBefore.length, targetBefore.length);
        const afterMax = Math.max(initialAfter.length, targetAfter.length);
        const beforeDenom = beforeMax === 0 ? 1 : beforeMax;
        const afterDenom = afterMax === 0 ? 1 : afterMax;
        const start = performance.now();

        if (targetState.showLook) {
            quoteEl.classList.remove('quote--no-look');
            quoteLookWrap.classList.remove('quote__lookWrap--hidden');
            quoteLook.textContent = targetLook;
        }

        const frame = (now) => {
            const elapsed = now - start;
            const progress = Math.min(elapsed / duration, 1);
            let beforeResult = '';
            let afterResult = '';

            for (let i = 0; i < beforeMax; i++) {
                if (progress > i / beforeDenom) {
                    beforeResult += targetBefore[i] ?? '';
                } else {
                    const fallback = initialBefore[i] ?? '';
                    const randomChar = glitchGlyphs[Math.floor(Math.random() * glitchGlyphs.length)] || fallback;
                    beforeResult += randomChar;
                }
            }

            for (let i = 0; i < afterMax; i++) {
                if (progress > i / afterDenom) {
                    afterResult += targetAfter[i] ?? '';
                } else {
                    const fallback = initialAfter[i] ?? '';
                    const randomChar = glitchGlyphs[Math.floor(Math.random() * glitchGlyphs.length)] || fallback;
                    afterResult += randomChar;
                }
            }

            quoteBefore.textContent = beforeResult;
            quoteAfter.textContent = afterResult;

            if (progress < 1) {
                requestAnimationFrame(frame);
            } else {
                quoteBefore.textContent = targetBefore;
                quoteAfter.textContent = targetAfter;
                quoteLook.textContent = targetLook;

                if (!targetState.showLook) {
                    quoteLookWrap.classList.add('quote__lookWrap--hidden');
                    quoteEl.classList.add('quote--no-look');
                } else {
                    requestAnimationFrame(captureLookAnchorPosition);
                }

                quoteEl.classList.remove('scrambling');
                delete quoteEl.dataset.swapping;

                if (typeof onComplete === 'function') {
                    onComplete();
                }
            }
        };

        requestAnimationFrame(frame);
    }

    function applyQuoteState(state, { immediate = false, duration, onComplete } = {}) {
        if (!state) return;

        if (immediate) {
            quoteBefore.textContent = state.before || '';
            quoteAfter.textContent = state.after || '';
            quoteLook.textContent = state.look || quoteLook.textContent || '';
            if (state.showLook) {
                quoteEl.classList.remove('quote--no-look');
                quoteLookWrap.classList.remove('quote__lookWrap--hidden');
                requestAnimationFrame(captureLookAnchorPosition);
            } else {
                quoteLookWrap.classList.add('quote__lookWrap--hidden');
                quoteEl.classList.add('quote--no-look');
            }
            quoteEl.classList.remove('scrambling');
            delete quoteEl.dataset.swapping;
            if (typeof onComplete === 'function') {
                onComplete();
            }
            return;
        }

        glitchSwapQuote(state, { duration, onComplete });
    }

    function typeLoomTail(text, index = 0) {
        if (index === 0) {
            loomTail.textContent = '';
        }

        if (index >= text.length) {
            loomworksTypingTimeout = null;
            return;
        }

        loomTail.textContent += text[index];
        const baseDelay = index < 3 ? 110 : 65;
        const jitter = Math.random() * 55;
        loomworksTypingTimeout = setTimeout(() => typeLoomTail(text, index + 1), baseDelay + jitter);
    }

    function startLoomworksReveal() {
        if (loomworksRevealStarted) return;
        loomworksRevealStarted = true;

        updateLoomworksOffset();
        loomworksEl.classList.add('visible');
        loomPre.textContent = 'L';
        loomCore.textContent = 'OO';
        loomPost.textContent = 'K';
        loomTail.textContent = '';

        setTimeout(() => {
            loomCore.classList.add('selected');
        }, 280);

        setTimeout(() => {
            loomCore.textContent = 'oo';
        }, 630);

        setTimeout(() => {
            loomCore.classList.remove('selected');
        }, 1080);

        setTimeout(() => {
            loomPost.classList.add('shift-right');
        }, 900);

        setTimeout(() => {
            loomPost.classList.add('selected');
            loomPost.style.opacity = '0.2';
        }, 980);

        setTimeout(() => {
            loomPost.textContent = 'm';
            loomPost.style.opacity = '1';
            loomPost.classList.remove('shift-right');
        }, 1340);

        setTimeout(() => {
            loomPost.classList.remove('selected');
            setTimeout(() => { loomPost.style.opacity = ''; }, 220);
        }, 1680);

        setTimeout(() => {
            loomPre.style.opacity = '0';
        }, 920);

        setTimeout(() => {
            loomPre.textContent = 'a L';
            loomPre.style.opacity = '1';
        }, 1340);

        setTimeout(() => {
            loomTail.classList.add('selected');
            setTimeout(() => {
                loomTail.classList.remove('selected');
                if (loomworksTypingTimeout) {
                    clearTimeout(loomworksTypingTimeout);
                }
                typeLoomTail('works Experience.');
            }, 260);
        }, 1380);
    }

    function animateLookKToLoom() {
        if (lookKSlidePromise) {
            return lookKSlidePromise;
        }

        lookKSlidePromise = new Promise((resolve) => {
            const lookNode = quoteLook.firstChild;
            const lookRect = quoteLook.getBoundingClientRect();
            const loomRect = loomPost.getBoundingClientRect();

            if ((!lookRect.width && !lookRect.height) || (!loomRect.width && !loomRect.height)) {
                resolve();
                return;
            }

            let kRect = lookRect;
            if (lookNode && lookNode.textContent && lookNode.textContent.length) {
                try {
                    const range = document.createRange();
                    const length = lookNode.textContent.length;
                    range.setStart(lookNode, Math.max(0, length - 1));
                    range.setEnd(lookNode, length);
                    const rects = range.getClientRects();
                    if (rects.length > 0) {
                        kRect = rects[rects.length - 1];
                    }
                    range.detach();
                } catch (err) {
                    // Fallback to full rect
                }
            }

            const startX = kRect.left + kRect.width / 2;
            const startY = kRect.top + kRect.height / 2;
            const endX = loomRect.left + loomRect.width / 2;
            const endY = loomRect.top + loomRect.height / 2;

            const floater = document.createElement('span');
            floater.className = 'look-k-floater';
            floater.textContent = 'K';
            floater.style.left = `${startX}px`;
            floater.style.top = `${startY}px`;
            floater.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(floater);

            const originalLook = quoteLook.textContent;
            if (originalLook && originalLook.length > 0) {
                quoteLook.textContent = originalLook.slice(0, -1);
            }

            requestAnimationFrame(() => {
                floater.style.opacity = '1';
                floater.style.transform = `translate(-50%, -50%) translate(${endX - startX}px, ${endY - startY}px)`;
            });

            const finish = () => {
                floater.style.opacity = '0';
                setTimeout(() => {
                    if (floater.parentNode) {
                        floater.parentNode.removeChild(floater);
                    }
                    quoteLook.textContent = originalLook;
                    resolve();
                }, 220);
            };

            const fallback = setTimeout(finish, 900);

            floater.addEventListener('transitionend', () => {
                clearTimeout(fallback);
                finish();
            }, { once: true });
        }).finally(() => {
            lookKSlideStarted = true;
        });

        return lookKSlidePromise;
    }

    function triggerBackspaceEasterEgg() {
        if (backspaceEffectState !== 'idle') return;
        const activeVoxels = voxels.filter(v => v.visible && !v.userData.glitched);
        if (!activeVoxels.length) return;
        backspaceEffectVoxel = activeVoxels[Math.floor(Math.random() * activeVoxels.length)];
        backspaceEffectStart = totalTime;
        backspaceEffectState = 'flicker';
    }

    function refreshPromptDisplay() {
        if (!promptTextEl || !promptCursorEl || !promptEl) return;
        promptTextEl.textContent = inputText;
        promptCursorEl.textContent = '_';
        promptEl.setAttribute('data-text', inputText + '_');
    }

    function handlePromptBackspace() {
        if (inputText.length <= basePromptText.length) return;
        inputText = inputText.slice(0, -1);
        tEntered = inputText.length > basePromptText.length;
        refreshPromptDisplay();
        if (hiddenInput) {
            hiddenInput.value = '';
        }
        triggerBackspaceEasterEgg();
    }
    
    function createTextParticle(x, y, text, color, sourceIndex) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.004 + Math.random() * 0.006;
        const particle = {
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            text,
            color,
            life: 1.0,
            age: 0,
            rotation: (Math.random() - 0.5) * 0.03,
            rotationSpeed: (Math.random() - 0.5) * 0.02,
            pulse: Math.random() * Math.PI * 2,
            sourceIndex,
            collapsing: false
        };
        textParticles.push(particle);
    }
    
    function updateTextParticles(dt) {
        for (let i = textParticles.length - 1; i >= 0; i--) {
            const p = textParticles[i];
            
            p.age += dt;
            
            // Get source sphere position
            const source = spheres[p.sourceIndex].position;
            
            // Calculate attraction to source (gravitational pull)
            const dx = source.x - p.x;
            const dy = source.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // After 1.8 seconds, begin dramatic collapse
            if (p.age > 1.8 && !p.collapsing) {
                p.collapsing = true;
            }
            
            if (p.collapsing) {
                // Dramatic collapse: strong pull, wild rotation, rapid fade
                const collapseForce = 0.0008 / (dist * dist + 0.01); // Much stronger!
                p.vx += (dx / dist) * collapseForce;
                p.vy += (dy / dist) * collapseForce;
                
                // Accelerate rotation
                p.rotationSpeed *= 1.05;
                
                // Rapid fade during collapse
                p.life -= dt * 2.5;
            } else {
                // Normal orbit phase
                if (dist > 0.01) {
                    const force = 0.00008 / (dist + 0.1);
                    p.vx += (dx / dist) * force;
                    p.vy += (dy / dist) * force;
                }
                
                // Apply orbital motion
                const orbitForce = 0.00012;
                p.vx += -dy * orbitForce;
                p.vy += dx * orbitForce;
                
                // Normal fade
                p.life -= dt * 0.5;
            }
            
            // Update position
            p.x += p.vx;
            p.y += p.vy;
            
            // Damping (less during collapse for dramatic effect)
            const dampFactor = p.collapsing ? 0.97 : 0.99;
            p.vx *= dampFactor;
            p.vy *= dampFactor;
            
            // Update rotation and pulse
            p.rotation += p.rotationSpeed;
            p.pulse += dt * (p.collapsing ? 8 : 4); // Faster pulse during collapse
            
            if (p.life <= 0) {
                textParticles.splice(i, 1);
            }
        }
    }
    
    function renderTextParticles(ctx, camera) {
        ctx.save();
        ctx.font = 'bold 16px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (const p of textParticles) {
            // Project from world to screen
            const screenX = (p.x / camera.right) * (window.innerWidth / 2) + (window.innerWidth / 2);
            const screenY = (-p.y / camera.top) * (window.innerHeight / 2) + (window.innerHeight / 2);
            
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(p.rotation);
            
            const alpha = p.life * p.life;
            const pulseFactor = 0.85 + Math.sin(p.pulse) * 0.15; // Gentle pulsate
            const glowSize = 5 + Math.sin(p.pulse * 0.7) * 3; // Slower, dreamy pulse
            
            // Scale down dramatically during collapse
            const scaleFactor = p.collapsing ? Math.max(0.1, 1.0 - (p.age - 1.8) * 1.2) : 1.0;
            ctx.scale(scaleFactor, scaleFactor);
            
            // Outer colored glow - intensify during collapse
            const collapseIntensity = p.collapsing ? 1.5 : 1.0;
            ctx.shadowBlur = glowSize * 4 * collapseIntensity;
            ctx.shadowColor = p.color;
            ctx.globalAlpha = alpha * 0.9 * collapseIntensity;
            ctx.fillStyle = p.color;
            ctx.fillText(p.text, 0, 0);
            
            // Mid white glow for visibility
            ctx.shadowBlur = glowSize * 2;
            ctx.shadowColor = '#ffffff';
            ctx.globalAlpha = alpha * 0.95;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(p.text, 0, 0);
            
            // Bright white base (always visible)
            ctx.shadowBlur = glowSize * 0.5;
            ctx.shadowColor = '#ffffff';
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(p.text, 0, 0);
            
            // Colored accent overlay
            ctx.shadowBlur = 0;
            ctx.globalAlpha = alpha * 0.4;
            ctx.fillStyle = p.color;
            ctx.fillText(p.text, 0, 0);
            
            ctx.restore();
        }
        ctx.restore();
    }
    
    function updateVoxels(t, dt) {
        const celliTime = t - introCfg.loomworksEnd;
        if (celliTime < 0) return;
        
        voxels.forEach(voxel => {
            const data = voxel.userData;
            
            // Skip glitched voxels - they're permanently disabled
            if (data.glitched) return;
            
            const localTime = celliTime - data.dropDelay;
            
            if (localTime < 0) return;
            
            voxel.visible = true;
            
            if (!data.settled) {
                // Dropping phase
                const targetY = data.targetY;
                if (voxel.position.y > targetY) {
                    voxel.position.y -= data.dropSpeed;
                    voxel.material.opacity = Math.min(0.8, voxel.material.opacity + 0.05);
                    data.edges.material.opacity = Math.min(0.6, data.edges.material.opacity + 0.04);
                } else {
                    // Hit the ground, settle
                    voxel.position.y = targetY;
                    data.settled = true;
                    data.settleTime = celliTime;
                    // Play chime sound on landing
                    playVoxelChime();
                }
            } else {
                // Jiggle and flicker phase
                const settleAge = celliTime - data.settleTime;

                // Jiggle (dampens over time)
                const jiggleFactor = Math.max(0, 1 - settleAge * 0.5);
                data.jigglePhase += dt * 20;
                const jiggleX = Math.sin(data.jigglePhase) * 0.003 * jiggleFactor;
                const jiggleY = Math.cos(data.jigglePhase * 1.3) * 0.002 * jiggleFactor;
                let posX = data.targetX + jiggleX;
                let posY = data.targetY + jiggleY;

                // Subtle scale bounce on landing for impact
                const scaleBounce = settleAge < 0.3 ? 1.0 + (1.0 - settleAge / 0.3) * 0.15 : 1.0;
                let scaleMultiplier = scaleBounce;

                if (backspaceEffectState !== 'pulse') {
                    // Flicker (gets brighter over time) - start very dim
                    data.flickerPhase += dt * 8;
                    const brightProgress = Math.min(1, settleAge * 0.25);  // Slower brightening
                    const flickerBase = THREE.MathUtils.lerp(0.1, 0.8, brightProgress);  // Start at 0.1, max 0.8
                    const flickerWave = Math.sin(data.flickerPhase) * 0.15;
                    voxel.material.opacity = flickerBase + flickerWave;

                    // Gradually brighten the voxel color from dim gray to bright white
                    const colorBrightness = THREE.MathUtils.lerp(0.2, 1.0, brightProgress);
                    voxel.material.color.setRGB(colorBrightness, colorBrightness, colorBrightness);

                    // Keep edges visible but subtle
                    data.edges.material.opacity = THREE.MathUtils.lerp(0.4, 0.3, brightProgress);
                }

                if (backspaceEffectState === 'pulse') {
                    const pulseAge = t - backspacePulseStart;
                    const vibrateDecay = Math.max(0, 1 - pulseAge / 2.5);
                    const offsetMag = 0.012 * vibrateDecay;
                    posX += Math.sin(pulseAge * 16 + data.pulsePhaseOffset) * offsetMag;
                    posY += Math.cos(pulseAge * 18 + data.pulsePhaseOffset) * offsetMag;
                    const pulseLift = Math.min(1, pulseAge / 1.2);
                    scaleMultiplier *= 1 + Math.sin(pulseAge * 5 + data.pulsePhaseOffset) * 0.15 * pulseLift;

                    if (data.pulseMaterial) {
                        const baseOpacity = 0.65 + Math.sin(pulseAge * 4 + data.pulsePhaseOffset) * 0.25 * vibrateDecay;
                        data.pulseMaterial.opacity = THREE.MathUtils.clamp(baseOpacity, 0.35, 0.95);
                        data.pulseMaterial.color.lerp(pulseHighlightColor, 0.08);
                    }
                }

                voxel.position.x = posX;
                voxel.position.y = posY;

                const finalScale = data.baseScale * scaleMultiplier;
                voxel.scale.set(finalScale, finalScale, finalScale);

                if (backspaceEffectState === 'flicker' && voxel === backspaceEffectVoxel) {
                    const flickerAge = t - backspaceEffectStart;
                    const flickerOn = Math.sin(flickerAge * 30) > 0;
                    voxel.material.opacity = flickerOn ? 1 : 0.2;
                    voxel.material.color.copy(flickerOn ? pulseHighlightColor : pulseBaseColor);
                }
            }
        });

        if (backspaceEffectState === 'flicker' && backspaceEffectVoxel) {
            const flickerAge = t - backspaceEffectStart;
            const flickerDuration = 0.6;
            if (flickerAge >= flickerDuration) {
                backspaceEffectState = 'pulse';
                backspacePulseStart = t;
                voxels.forEach(voxel => {
                    const data = voxel.userData;
                    if (data.glitched) return;
                    voxel.geometry = roundedVoxelGeo;
                    if (data.pulseMaterial) {
                        data.pulseMaterial.dispose();
                    }
                    if (voxel.material && voxel.material.dispose) {
                        voxel.material.dispose();
                    }
                    const pulseMaterial = new THREE.MeshBasicMaterial({
                        color: pulseBaseColor.clone(),
                        transparent: true,
                        opacity: 0.68,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });
                    voxel.material = pulseMaterial;
                    data.pulseMaterial = pulseMaterial;
                    if (data.edges && data.edges.material) {
                        data.edges.material.color.copy(pulseEdgeColor);
                        data.edges.material.opacity = 0.9;
                    }
                });
                backspaceEffectVoxel = null;
            }
        }
    }
    
    // CELLI glitch and degradation
    function triggerCelliGlitch() {
        if (celliGlitchStarted) return;
        celliGlitchStarted = true;
        
        // Play electrical fritz whir/buzz sound
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        
        // Create buzzing electrical sound with multiple oscillators
        const buzz1 = audioCtx.createOscillator();
        const buzz2 = audioCtx.createOscillator();
        const buzz3 = audioCtx.createOscillator();
        const buzzGain = audioCtx.createGain();
        const buzzFilter = audioCtx.createBiquadFilter();
        
        buzz1.type = 'sawtooth';
        buzz2.type = 'square';
        buzz3.type = 'sawtooth';
        
        // Fluctuating frequencies for electrical buzz
        buzz1.frequency.setValueAtTime(120, now);
        buzz2.frequency.setValueAtTime(180, now);
        buzz3.frequency.setValueAtTime(240, now);
        
        // Modulate frequencies to create buzzing effect
        for (let i = 0; i < 20; i++) {
            const t = now + (i * 0.1);
            const freq1 = 120 + Math.random() * 60;
            const freq2 = 180 + Math.random() * 60;
            const freq3 = 240 + Math.random() * 60;
            buzz1.frequency.setValueAtTime(freq1, t);
            buzz2.frequency.setValueAtTime(freq2, t);
            buzz3.frequency.setValueAtTime(freq3, t);
        }
        
        // Band-pass filter for electrical character
        buzzFilter.type = 'bandpass';
        buzzFilter.frequency.setValueAtTime(300, now);
        buzzFilter.Q.setValueAtTime(5, now);
        
        // Envelope: fade in, sustain, fade out
        buzzGain.gain.setValueAtTime(0, now);
        buzzGain.gain.linearRampToValueAtTime(0.08, now + 0.2);
        buzzGain.gain.setValueAtTime(0.08, now + 1.5);
        buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
        
        buzz1.connect(buzzFilter);
        buzz2.connect(buzzFilter);
        buzz3.connect(buzzFilter);
        buzzFilter.connect(buzzGain);
        buzzGain.connect(audioCtx.destination);
        
        buzz1.start(now);
        buzz2.start(now);
        buzz3.start(now);
        buzz1.stop(now + 2.0);
        buzz2.stop(now + 2.0);
        buzz3.stop(now + 2.0);
        
        // Start flickering lights
        document.getElementById('screenGlitch').classList.add('active');
        
        // Only keep the middle column of I (letter index 4, middle 3 rows: 1,2,3)
        voxels.forEach((voxel, idx) => {
            const data = voxel.userData;
            const gridX = data.gridX;    // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)
            const gridY = data.gridY;    // Row index (0=top, 4=bottom)
            const gridCol = data.gridCol; // Column index within letter (0-4)
            
            // Keep only the T shape: top bar (row 0, all cols) and vertical stem (rows 1-4, middle col)
            const keepVoxel = (gridX === 4 && ((gridY === 0) || (gridY >= 1 && gridY <= 4 && gridCol === 2)));
            
            if (!keepVoxel) {
                // Mark as glitched immediately to prevent updates
                data.glitched = true;
                
                // Start flickering with light gray
                const flickerDelay = Math.random() * 400;
                
                setTimeout(() => {
                    // Turn to light gray and start flickering
                    voxel.material.color.setRGB(0.6, 0.6, 0.6); // Light gray
                    data.edges.material.color.setRGB(0.65, 0.65, 0.65);
                    
                    const flickerDuration = 400 + Math.random() * 400;
                    let flickerCount = 0;
                    const maxFlickers = Math.floor(flickerDuration / 60);
                    
                    const flickerInterval = setInterval(() => {
                        flickerCount++;
                        const flickerOn = Math.random() > 0.5;
                        
                        // Flicker between light gray and white, gradually dimming
                        const dimFactor = 1 - (flickerCount / maxFlickers) * 0.5;
                        if (flickerOn) {
                            voxel.material.color.setRGB(0.6 * dimFactor, 0.6 * dimFactor, 0.6 * dimFactor);
                            voxel.material.opacity = 0.75 * dimFactor;
                            data.edges.material.opacity = 0.5 * dimFactor;
                        } else {
                            voxel.material.color.setRGB(0.4 * dimFactor, 0.4 * dimFactor, 0.4 * dimFactor);
                            voxel.material.opacity = 0.5 * dimFactor;
                            data.edges.material.opacity = 0.3 * dimFactor;
                        }
                    }, 60);
                    
                    // After flickering, turn dark gray and fade out
                    setTimeout(() => {
                        clearInterval(flickerInterval);
                        
                        // Short out - dark gray
                        voxel.material.color.setRGB(0.15, 0.15, 0.15); // Dark gray
                        data.edges.material.color.setRGB(0.2, 0.2, 0.2);
                        voxel.material.opacity = 0.4;
                        data.edges.material.opacity = 0.25;
                        
                        // Fade to black over time
                        const fadeStart = Date.now();
                        const fadeDuration = 300;
                        const fadeInterval = setInterval(() => {
                            const fadeProgress = (Date.now() - fadeStart) / fadeDuration;
                            if (fadeProgress >= 1) {
                                clearInterval(fadeInterval);
                                voxel.material.opacity = 0;
                                data.edges.material.opacity = 0;
                                voxel.visible = false;
                                data.edges.visible = false;
                            } else {
                                voxel.material.opacity = 0.4 * (1 - fadeProgress);
                                data.edges.material.opacity = 0.25 * (1 - fadeProgress);
                            }
                        }, 16);
                    }, flickerDuration);
                }, flickerDelay);
            }
        });
        
        // Stop screen glitch after 2 seconds
        setTimeout(() => {
            document.getElementById('screenGlitch').classList.remove('active');
        }, 2000);
    }

    function updatePositions(t) {
        const phase = t < introCfg.rollEnd ? 'roll' :
                      t < introCfg.bounceEnd ? 'bounce' :
                      t < introCfg.triangleEnd ? 'triangle' :
                      t < introCfg.transitionEnd ? 'transition' :
                      t < introCfg.normalEnd ? 'normal' :
                      t < introCfg.vennEnd ? 'venn' :
                      t < introCfg.collapseEnd ? 'collapse' :
                      t < introCfg.glitchEnd ? 'glitch' :
                      t < introCfg.blackoutEnd ? 'blackout' :
                      t < introCfg.loomworksEnd ? 'loomworks' :
                      t < introCfg.celliEnd ? 'celli' : 'doorway';

        // Animate bloom, afterimage, and film effects based on phase
        if (phase === 'roll') {
            afterimagePass.uniforms.damp.value = 0.75; // Thin trail
            filmPass.uniforms.noise.value = 0.005; // Minimal grain
            filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines
            triMesh.visible = false; // Hide triangle gradient during intro
        } else if (phase === 'bounce') {
            bloomPass.strength = 0.25; // Subtle glow
            afterimagePass.uniforms.damp.value = 0.75; // Thin trail
            filmPass.uniforms.noise.value = 0.005; // Minimal grain
            filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines
            triMesh.visible = false; // Hide triangle gradient during intro
        } else if (phase === 'triangle') {
            const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);
            
            // Sub-phases: form (0-0.35), converge (0.35-0.6), grow (0.6-1.0)
            const formProgress = Math.min(triangleProgress / 0.35, 1.0);
            const convergeStart = 0.35;
            const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;
            const growStart = 0.6;
            const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;
            
            // Smooth bloom progression throughout all sub-phases
            bloomPass.strength = THREE.MathUtils.lerp(0.25, 0.7, triangleProgress);
            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.75, 0.92, triangleProgress);
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.005, 0.015, triangleProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.003, 0.015, triangleProgress);
            
            // Hide triangle gradient - it makes things look off-center
            triMesh.visible = false;
            triMesh.material.opacity = 0;
        } else if (phase === 'transition') {
            // Transform triangle into rotating circular orbit - organically
            // ALSO morph all shapes into circles
            const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);
            const easeInOut = (p) => (p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2);
            const eased = easeInOut(transProgress);

            // Morph shapes into circles halfway through transition
            // Keep materials (colors) consistent - don't swap
            if (transProgress > 0.5 && spheres[0].geometry !== circleGeoTarget && spheres[1].geometry !== circleGeoTarget) {
                const mat0 = spheres[0].material;
                const mat1 = spheres[1].material;

                spheres[0].geometry.dispose();
                spheres[0].geometry = createCircle(R);
                spheres[0].material = mat0;  // Preserve cyan

                spheres[1].geometry.dispose();
                spheres[1].geometry = createCircle(R);
                spheres[1].material = mat1;  // Preserve yellow

                // spheres[2] is already a circle (magenta)
            }

            const centerY = 0;
            const triangleRadius = 0.42;

            // Use same equilateral triangle angles
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];

            // Starting radius (with 12% convergence from triangle phase)
            const startRadius = triangleRadius * (1 - 0.12);

            // Calculate rotation to match end of triangle phase (which uses rotationAmount = 0.2)
            // The triangle phase maps spheres with triangleMapping, so we need to continue from there
            const triangleEndRotation = 0.2; // matches growEased = 1.0 * 0.2
            const rotation = triangleEndRotation + (eased * Math.PI * 2);

            const targetDist = motionCfg.maxDist * 0.5;
            const convergeEnd = 0.55;
            const holdEnd = Math.min(0.95, convergeEnd + 0.1);
            const minDist = triangleRadius * 0.12;
            let currentDist = startRadius;

            if (transProgress < convergeEnd) {
                const convergeProgress = easeInOut(Math.min(transProgress / convergeEnd, 1));
                currentDist = THREE.MathUtils.lerp(startRadius, minDist, convergeProgress);
            } else if (transProgress < holdEnd) {
                currentDist = minDist;
            } else {
                const repelProgress = easeInOut(Math.min((transProgress - holdEnd) / (1 - holdEnd), 1));
                currentDist = THREE.MathUtils.lerp(minDist, targetDist, repelProgress);
            }

            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];

            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotation;
                const x = Math.cos(angle) * currentDist;
                const y = Math.sin(angle) * currentDist + centerY;

                spheres[i].position.set(x, y, -i * 0.002);
                spheres[i].rotation.z = 0;
                const scale = THREE.MathUtils.lerp(introCfg.ballSize * 2.2, 1.0, eased);
                spheres[i].scale.set(scale, scale, scale);
                triMat.uniforms.points.value[i].set(x, y);
            }

            let bloomStrength;
            if (transProgress < convergeEnd) {
                const convergeProgress = Math.min(transProgress / convergeEnd, 1);
                bloomStrength = THREE.MathUtils.lerp(0.25, 0.75, easeInOut(convergeProgress));
            } else if (transProgress < holdEnd) {
                bloomStrength = 0.75;
            } else {
                const repelProgress = Math.min((transProgress - holdEnd) / (1 - holdEnd), 1);
                bloomStrength = THREE.MathUtils.lerp(0.75, 0.85, easeInOut(repelProgress));
            }
            bloomPass.strength = bloomStrength;

            const filmEase = easeInOut(Math.min(transProgress / Math.max(holdEnd, 0.0001), 1));
            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.92, 0.96, filmEase);
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);

            if (transProgress < holdEnd) {
                triMesh.visible = false;
                triMesh.material.opacity = 0;
            } else {
                const repelProgress = Math.min((transProgress - holdEnd) / (1 - holdEnd), 1);
                triMesh.visible = true;
                triMesh.material.opacity = THREE.MathUtils.lerp(0, 0.7, easeInOut(repelProgress));
            }

            blackHole.visible = true;
            const pulseMix = transProgress < convergeEnd ? 0.4 : 0.5;
            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.4, pulseMix, eased);

        } else if (phase === 'normal') {
            // Normal pulsing/converging animation
            const normalT = t - introCfg.transitionEnd;
            const pulseFactor = 0.5 + 0.5 * Math.sin(normalT * motionCfg.speed);
        const currentDist = motionCfg.maxDist * pulseFactor;
        const scale = THREE.MathUtils.lerp(motionCfg.minScale, 1.0, pulseFactor);

            // Continue from where transition left off - use equilateral angles
            const centerY = 0;
            
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            // Start from where transition ended: 0.2 + 2π
            const transitionEndRotation = 0.2 + Math.PI * 2;
            const rotation = transitionEndRotation + (normalT * motionCfg.rotationSpeed);

            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];

        for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotation;
            const p = new THREE.Vector2(
                Math.cos(angle) * currentDist,
                    Math.sin(angle) * currentDist + centerY
            );
            spheres[i].position.set(p.x, p.y, -i * 0.002);
                spheres[i].rotation.z = 0;
            spheres[i].scale.set(scale, scale, scale);
            triMat.uniforms.points.value[i].copy(p);
        }
            blackHole.visible = true;
        blackHole.material.uniforms.pulseFactor.value = pulseFactor;
            
        } else if (phase === 'venn') {
            // Slow down and form clear venn diagram
            const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);
            // Smooth cubic easing
            const eased = vennProgress < 0.5 ? 
                4 * vennProgress * vennProgress * vennProgress : 
                1 - Math.pow(-2 * vennProgress + 2, 3) / 2;
            
            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
            const centerY = 0;
            
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            // Start from where normal ended: transitionEndRotation + normalDuration * rotationSpeed
            const transitionEndRotation = 0.2 + Math.PI * 2;
            const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed);
            const vennT = t - introCfg.normalEnd;
            const slowRotation = baseRotation + (vennT * motionCfg.rotationSpeed * 0.3); // Slow down to 30%
            
            // Settle into venn diagram distance - calculate what pulse factor was at END of normal phase
            const normalEndTime = introCfg.normalEnd - introCfg.transitionEnd;
            const startPulseFactor = 0.5 + 0.5 * Math.sin(normalEndTime * motionCfg.speed);
            const startDist = motionCfg.maxDist * startPulseFactor;
            const targetDist = 0.08; // Very close for dramatic overlap
            const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);
            const scale = THREE.MathUtils.lerp(1.0, 0.7, eased); // Much larger for awesome venn!

            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];

            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + slowRotation;
                const p = new THREE.Vector2(
                    Math.cos(angle) * currentDist,
                    Math.sin(angle) * currentDist + centerY
                );
                spheres[i].position.set(p.x, p.y, -i * 0.002);
                spheres[i].rotation.z = 0;
                spheres[i].scale.set(scale, scale, scale);
                triMat.uniforms.points.value[i].copy(p);
            }
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(startPulseFactor, 0.6, eased);
            
            if (!quoteShown) {
                applyQuoteState(quoteStates.initial, { immediate: true });
                quoteEl.classList.remove('scrambling', 'glitch', 'glitchMedium', 'glitchIntense');
                document.getElementById('quote').classList.add('visible');
                quoteLookSwapped = false;
                quoteDespairShown = false;
                quoteShown = true;
            }
            
        } else if (phase === 'collapse') {
            // Grow and collapse into white radiating circle
            const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);
            // Smooth cubic easing
            const eased = collapseProgress < 0.5 ? 
                4 * collapseProgress * collapseProgress * collapseProgress : 
                1 - Math.pow(-2 * collapseProgress + 2, 3) / 2;
            
            const centerY = 0;
            
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            // Start from where venn ended
            const transitionEndRotation = 0.2 + Math.PI * 2;
            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
            const vennDuration = introCfg.vennEnd - introCfg.normalEnd;
            const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed) + (vennDuration * motionCfg.rotationSpeed * 0.3);
            const collapseT = t - introCfg.vennEnd;
            const rotation = baseRotation + (collapseT * motionCfg.rotationSpeed * 0.15); // Even slower
            
            // Collapse to tiny overlap while growing in size
            const startDist = 0.08;
            const targetDist = 0.005;
            const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);
            const scale = THREE.MathUtils.lerp(0.7, 0.85, eased); // Massive spheres!

            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];

        for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotation;
            const p = new THREE.Vector2(
                Math.cos(angle) * currentDist,
                    Math.sin(angle) * currentDist + centerY
            );
            spheres[i].position.set(p.x, p.y, -i * 0.002);
            spheres[i].rotation.z = 0;
            spheres[i].scale.set(scale, scale, scale);
            triMat.uniforms.points.value[i].copy(p);
        }
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.6, 0.85, eased);
            
            if (collapseProgress > 0.3 && !glitchStarted) {
                document.getElementById('quote').classList.add('glitch');
                glitchStarted = true;
            }
            
            if (collapseProgress > 0.45 && !quoteLookSwapped) {
                glitchSwapQuote(quoteStates.look, { duration: 1200, onComplete: () => quoteEl.classList.remove('quote--loom') });
                quoteLookSwapped = true;
            }
            
        } else if (phase === 'glitch' || phase === 'blackout' || phase === 'loomworks' || phase === 'celli') {
            // Hide spheres during ending sequence, keep last position
            const centerY = 0;
            const targetDist = 0.005;
            const scale = 0.85;
            
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            const slowRotation = t * 0.05;
            
            // Fade out spheres during glitch phase
            let sphereOpacity = 1.0;
            if (phase === 'glitch') {
                const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
                sphereOpacity = THREE.MathUtils.lerp(1.0, 0, glitchProgress);
                if (glitchProgress > 0.25 && !quoteDespairShown) {
                    glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });
                    quoteDespairShown = true;
                }
            } else {
                sphereOpacity = 0;
            }
            
            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];
            
            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + slowRotation;
                const p = new THREE.Vector2(
                    Math.cos(angle) * targetDist,
                    Math.sin(angle) * targetDist + centerY
                );
                spheres[i].position.set(p.x, p.y, -i * 0.002);
                spheres[i].rotation.z = 0;
                spheres[i].scale.set(scale, scale, scale);
                spheres[i].material.opacity = sphereOpacity;
            triMat.uniforms.points.value[i].copy(p);
        }

            blackHole.visible = phase === 'glitch';
            if (phase === 'glitch') {
                const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
                blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.85, 0, glitchProgress);
            }
        }
    }

    // --- Responsive ---------------------------------------------------------
    function onResize(){
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      const aspect = window.innerWidth / window.innerHeight;
      triMat.uniforms.aspect.value = aspect;
      if (aspect > 1) { // Landscape
          camera.left = -aspect; camera.right = aspect; camera.top = 1; camera.bottom = -1;
          // Scale black hole to maintain circularity
          blackHole.scale.set(1, 1, 1);
      } else { // Portrait
          camera.left = -1; camera.right = 1; camera.top = 1 / aspect; camera.bottom = -1 / aspect;
          // Scale black hole to maintain circularity
          blackHole.scale.set(aspect, aspect, 1);
      }
      camera.updateProjectionMatrix();
      
      // Recalculate CELLI scale for responsive layout
      const oldScale = celliScale;
      calculateCelliScale();

      // Update voxel positions and scales based on new scale
      if (oldScale !== celliScale) {
          const scaleRatio = celliScale / oldScale;
          voxels.forEach((voxel) => {
              const data = voxel.userData;
              // Update positions with new scale
              data.targetX *= scaleRatio;
              data.targetY *= scaleRatio;
              data.baseScale = celliScale;
              
              // Update actual positions if settled
              if (data.settled) {
                  voxel.position.x = data.targetX;
                  voxel.position.y = data.targetY;
              }
              
              // Update scale
              voxel.scale.set(celliScale, celliScale, celliScale);
          });
      }
    }
    window.addEventListener('resize', onResize);
    onResize();

    // --- Animate (gated by Play) -------------------------------------------
    const clock = new THREE.Clock();
    let running = false, totalTime = 0;
    
    // Canvas for text particles
    const textCanvas = document.createElement('canvas');
    textCanvas.style.position = 'fixed';
    textCanvas.style.inset = '0';
    textCanvas.style.pointerEvents = 'none';
    textCanvas.style.zIndex = '5';
    document.body.appendChild(textCanvas);
    const textCtx = textCanvas.getContext('2d');
    
    function resizeTextCanvas() {
        textCanvas.width = window.innerWidth;
        textCanvas.height = window.innerHeight;
    }
    resizeTextCanvas();
    window.addEventListener('resize', resizeTextCanvas);
    
     // Gentle thunk sound for rolling (lighter than landing)
     function playRollingThunk(volume = 0.08, delay = 0) {
         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
         const now = audioCtx.currentTime + delay;
         
         // Subtle rolling "tap" sound
         const osc = audioCtx.createOscillator();
         const gain = audioCtx.createGain();
         
         osc.type = 'sine';
         osc.frequency.setValueAtTime(100 + Math.random() * 20, now); // Slight variation
         osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);
         
         gain.gain.setValueAtTime(volume, now);
         gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
         
         osc.connect(gain);
         gain.connect(audioCtx.destination);
         osc.start(now);
         osc.stop(now + 0.15);
     }
     
     // Heavier thud for jumps and landings
     function playBounceThud(volume = 0.15, delay = 0) {
         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
         const now = audioCtx.currentTime + delay;
         
         // Deep impact sound
         const osc = audioCtx.createOscillator();
         const gain = audioCtx.createGain();
         
         osc.type = 'sine';
         osc.frequency.setValueAtTime(60, now); // Deep thud
         osc.frequency.exponentialRampToValueAtTime(30, now + 0.15);
         
         gain.gain.setValueAtTime(volume, now);
         gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
         
         osc.connect(gain);
         gain.connect(audioCtx.destination);
         osc.start(now);
         osc.stop(now + 0.25);
     }
     
     // Hollow melodic chime for voxel landing - C pentatonic scale
     function playVoxelChime(delay = 0) {
         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
         const now = audioCtx.currentTime + delay;
         
         // Pentatonic scale notes for melodic chimes (C, D, E, G, A)
         const pentatonicNotes = [523.25, 587.33, 659.25, 783.99, 880]; // C5, D5, E5, G5, A5
         const fundamentalFreq = pentatonicNotes[Math.floor(Math.random() * pentatonicNotes.length)];
         
         // Hollow sound: triangle wave with filtered overtones
         const osc1 = audioCtx.createOscillator();
         const osc2 = audioCtx.createOscillator();
         const osc3 = audioCtx.createOscillator();
         const filter = audioCtx.createBiquadFilter();
         const gain = audioCtx.createGain();
         
         osc1.type = 'triangle'; // Hollow fundamental
         osc1.frequency.setValueAtTime(fundamentalFreq, now);
         
         osc2.type = 'sine'; // Soft overtone
         osc2.frequency.setValueAtTime(fundamentalFreq * 3, now);
         
         osc3.type = 'sine'; // Gentle fifth
         osc3.frequency.setValueAtTime(fundamentalFreq * 1.5, now);
         
         // Band-pass filter for hollow character
         filter.type = 'bandpass';
         filter.frequency.setValueAtTime(fundamentalFreq * 2, now);
         filter.Q.setValueAtTime(2, now);
         
         // Gentle envelope
         gain.gain.setValueAtTime(0, now);
         gain.gain.linearRampToValueAtTime(0.03, now + 0.01);
         gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
         
         osc1.connect(filter);
         osc2.connect(gain);
         osc3.connect(gain);
         filter.connect(gain);
         gain.connect(audioCtx.destination);
         
         osc1.start(now);
         osc2.start(now);
         osc3.start(now);
         osc1.stop(now + 1.2);
         osc2.stop(now + 1.2);
         osc3.stop(now + 1.2);
     }
    
    // Chiptune music system - simple arpeggio + drums
    let chiptuneBass = null;
    let chiptuneGain = null;
    let lastNoteTime = 0;
    let lastDrumTime = 0;
    let noteIndex = 0;
    let drumIndex = 0;
    let musicStarted = false;
    let reverbDelay = null;
    let reverbGain = null;
    let reverbFeedback = null;
    let glitchWhirOsc1 = null;
    let glitchWhirOsc2 = null;
    let glitchWhirOsc3 = null;
    let glitchWhirGain = null;
    let glitchWhirFilter = null;
    let glitchWhirStarted = false;
    
    function updateSynth(t) {
        // Start music during triangle phase
        if (!musicStarted && t > introCfg.bounceEnd) {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create reverb delay effect
            reverbDelay = audioCtx.createDelay(2.0);
            reverbDelay.delayTime.value = 0.25; // 250ms delay
            reverbGain = audioCtx.createGain();
            reverbGain.gain.value = 0.3; // Moderate reverb mix
            reverbFeedback = audioCtx.createGain();
            reverbFeedback.gain.value = 0.4; // Feedback for reverb tail
            
            // Wire up reverb: delay -> feedback -> delay (loop) + output
            reverbDelay.connect(reverbFeedback);
            reverbFeedback.connect(reverbDelay);
            reverbDelay.connect(reverbGain);
            reverbGain.connect(audioCtx.destination);
            
            musicStarted = true;
            lastNoteTime = t;
            lastDrumTime = t;
        }
        
        if (!musicStarted || !audioCtx) return;
        
        const now = audioCtx.currentTime;
        
        // Determine arpeggio and rhythm based on phase
        let arpeggio = [];
        let noteSpeed = 0.25;
        let drumSpeed = 0.5;
        let drumVolume = 0.12;
        let drumReverb = 0.2;
        let reverbMix = 0.3;
        let glitchLevel = 0;
        
        if (t < introCfg.triangleEnd) {
            // Calm, contemplative Am progression
            arpeggio = [220.00, 261.63, 329.63, 261.63]; // A3, C4, E4, C4
            noteSpeed = 0.5;
            drumSpeed = 1.2;
            drumVolume = 0.08;
            drumReverb = 0.25;
            reverbMix = 0.35;
        } else if (t < introCfg.normalEnd) {
            // Gentle progression with suspension
            arpeggio = [220.00, 246.94, 293.66, 329.63, 293.66, 246.94]; // A3, B3, D4, E4, D4, B3
            noteSpeed = 0.45;
            drumSpeed = 1.0;
            drumVolume = 0.1;
            drumReverb = 0.3;
            reverbMix = 0.4;
        } else if (t < introCfg.vennEnd) {
            // Subdued, introspective
            arpeggio = [196.00, 246.94, 293.66, 349.23, 293.66, 246.94]; // G3, B3, D4, F4, D4, B3
            noteSpeed = 0.4;
            drumSpeed = 0.9;
            drumVolume = 0.12;
            drumReverb = 0.4;
            reverbMix = 0.45;
        } else if (t < introCfg.collapseEnd) {
            // Building unease, drums more present
            arpeggio = [220.00, 277.18, 329.63, 392.00, 329.63, 277.18]; // A3, C#4, E4, G4, E4, C#4
            noteSpeed = 0.38;
            drumSpeed = 0.7;
            drumVolume = 0.16; // Drums becoming more prominent
            drumReverb = 0.6;
            reverbMix = 0.5;
            glitchLevel = 0.1;
        } else if (t < introCfg.glitchEnd) {
            // Dissonant breakdown, drums dominate
            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
            arpeggio = [233.08, 277.18, 369.99, 415.30]; // Diminished, unsettling
            noteSpeed = 0.35;
            drumSpeed = 0.55;
            drumVolume = THREE.MathUtils.lerp(0.18, 0.28, glitchProgress); // Drums take over
            drumReverb = THREE.MathUtils.lerp(0.6, 0.85, glitchProgress);
            reverbMix = THREE.MathUtils.lerp(0.5, 0.65, glitchProgress);
            glitchLevel = THREE.MathUtils.lerp(0.2, 0.8, glitchProgress);
        } else {
            return;
        }
        
        // Update reverb mix
        if (reverbGain) {
            reverbGain.gain.setTargetAtTime(reverbMix, now, 0.5);
        }
        
        // Play arpeggio notes
        if (t - lastNoteTime >= noteSpeed) {
            const freq = arpeggio[noteIndex % arpeggio.length];
            playChiptuneNote(freq, noteSpeed * 0.9, glitchLevel, reverbDelay);
            noteIndex++;
            lastNoteTime = t;
        }
        
        // Play drum beats
        if (t - lastDrumTime >= drumSpeed) {
            playChiptuneDrum(drumVolume, drumReverb, glitchLevel, reverbDelay);
            drumIndex++;
            lastDrumTime = t;
        }
        
        // Corrupted whir during glitch phase
        if (t >= introCfg.collapseEnd && t < introCfg.glitchEnd) {
            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
            
            if (!glitchWhirStarted) {
                // Start the harsh whirring synth
                glitchWhirOsc1 = audioCtx.createOscillator();
                glitchWhirOsc2 = audioCtx.createOscillator();
                glitchWhirOsc3 = audioCtx.createOscillator();
                glitchWhirGain = audioCtx.createGain();
                glitchWhirFilter = audioCtx.createBiquadFilter();
                
                // Triangle waves for harsh, mechanical sound
                glitchWhirOsc1.type = 'triangle';
                glitchWhirOsc2.type = 'triangle';
                glitchWhirOsc3.type = 'triangle';
                
                // Detuning for thickness
                glitchWhirOsc1.detune.value = -8;
                glitchWhirOsc2.detune.value = 0;
                glitchWhirOsc3.detune.value = 8;
                
                // Start at low frequency
                glitchWhirOsc1.frequency.setValueAtTime(220, now);
                glitchWhirOsc2.frequency.setValueAtTime(220, now);
                glitchWhirOsc3.frequency.setValueAtTime(220, now);
                
                // Resonant filter for harsh whir
                glitchWhirFilter.type = 'lowpass';
                glitchWhirFilter.frequency.setValueAtTime(400, now);
                glitchWhirFilter.Q.setValueAtTime(8, now);
                
                glitchWhirGain.gain.setValueAtTime(0, now);
                glitchWhirGain.gain.linearRampToValueAtTime(0.08, now + 0.5);
                
                glitchWhirOsc1.connect(glitchWhirFilter);
                glitchWhirOsc2.connect(glitchWhirFilter);
                glitchWhirOsc3.connect(glitchWhirFilter);
                glitchWhirFilter.connect(glitchWhirGain);
                glitchWhirGain.connect(audioCtx.destination);
                
                glitchWhirOsc1.start(now);
                glitchWhirOsc2.start(now);
                glitchWhirOsc3.start(now);
                
                glitchWhirStarted = true;
            }
            
            // Modulate frequency for failing sound
            if (glitchWhirOsc1) {
                const crackle = Math.sin(t * 100) * 20 * glitchProgress;
                const whir = Math.sin(t * 30) * 10;
                const baseFreq = THREE.MathUtils.lerp(220, 55, glitchProgress); // Pitch down as it fails
                
                glitchWhirOsc1.frequency.setTargetAtTime(baseFreq + crackle + whir, now, 0.02);
                glitchWhirOsc2.frequency.setTargetAtTime(baseFreq + crackle + whir * 1.1, now, 0.02);
                glitchWhirOsc3.frequency.setTargetAtTime(baseFreq + crackle + whir * 0.9, now, 0.02);
                
                // Filter sweep downward
                glitchWhirFilter.frequency.setTargetAtTime(THREE.MathUtils.lerp(400, 100, glitchProgress), now, 0.1);
                
                // Volume swell and fade
                const vroomPhase = Math.sin(t * 2) * 0.5 + 0.5;
                const fadeOut = 1 - glitchProgress * 0.7; // Fade out near end
                glitchWhirGain.gain.setTargetAtTime(0.08 * fadeOut * vroomPhase, now, 0.05);
            }
        } else if (glitchWhirStarted && glitchWhirOsc1) {
            // Stop the whir after glitch phase
            glitchWhirOsc1.stop(now + 0.5);
            glitchWhirOsc2.stop(now + 0.5);
            glitchWhirOsc3.stop(now + 0.5);
            glitchWhirOsc1 = null;
            glitchWhirOsc2 = null;
            glitchWhirOsc3 = null;
        }
    }
    
    // Chiptune note player - muted, musical synth
    function playChiptuneNote(freq, duration, glitchLevel = 0, reverbNode = null) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        
        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        
        // Sine waves for muted, warm tone
        osc1.type = 'sine';
        osc2.type = 'sine';
        
        // Add subtle harmonic (5th) for richness
        const glitchWobble = glitchLevel > 0 ? (Math.random() - 0.5) * freq * glitchLevel * 0.2 : 0;
        osc1.frequency.setValueAtTime(freq + glitchWobble, now);
        osc2.frequency.setValueAtTime((freq * 1.5) + glitchWobble, now); // Perfect 5th
        
        // Muted low-pass filter
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(glitchLevel > 0.5 ? 600 : 1200, now);
        filter.Q.setValueAtTime(0.3, now);
        
        // Very soft, gentle envelope
        const baseVol = 0.045 * (1 - glitchLevel * 0.3);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(baseVol, now + 0.03);
        gain.gain.setValueAtTime(baseVol * 0.85, now + duration * 0.5);
        gain.gain.linearRampToValueAtTime(0, now + duration);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        
        // Connect to reverb if available
        if (reverbNode) {
            gain.connect(reverbNode);
        }
        
        osc1.start(now);
        osc2.start(now);
        osc1.stop(now + duration);
        osc2.stop(now + duration);
    }
    
    // Chiptune drum player
    function playChiptuneDrum(volume = 0.12, reverbAmount = 0.3, glitchLevel = 0, reverbNode = null) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        
        // Kick drum
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const reverbSend = audioCtx.createGain();
        
        osc.type = 'sine';
        const startFreq = glitchLevel > 0.5 ? 80 + Math.random() * 40 : 60;
        osc.frequency.setValueAtTime(startFreq, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
        
        // Main drum volume (dominant)
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        
        // Reverb send amount
        reverbSend.gain.setValueAtTime(volume * reverbAmount, now);
        reverbSend.gain.exponentialRampToValueAtTime(0.001, now + 0.3); // Longer reverb tail
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        // Send to reverb
        if (reverbNode) {
            osc.connect(reverbSend);
            reverbSend.connect(reverbNode);
        }
        
        osc.start(now);
        osc.stop(now + 0.3);
    }
    
    function frame(){
      if(!running) return;
      const dt = Math.min(clock.getDelta(), 0.033);
      totalTime += dt;
      updatePositions(totalTime);
      updateSynth(totalTime);
      blackHole.material.uniforms.time.value = totalTime;
      filmPass.uniforms.time.value += dt;
      composer.render();
      
      // Update and render text particles
      updateTextParticles(dt);
      textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
      renderTextParticles(textCtx, camera);
      
      // Update voxels for CELLI animation
      updateVoxels(totalTime, dt);
      
      // Update floating voxels during burst
      updateFloatingVoxels(dt);
      
      // Update camera pan
      updateCameraPan();
      
      requestAnimationFrame(frame);
    }

    // --- Click interaction on spheres ----------------------------------------
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    renderer.domElement.addEventListener('click', (event) => {
        if (!running) return;
        
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(spheres);
        
        if (intersects.length > 0) {
            const hitSphere = intersects[0].object;
            const sphereIndex = spheres.indexOf(hitSphere);
            const hitPos = intersects[0].point;
            
            // Burst particles based on color
            let texts, color;
            if (sphereIndex === 0) { // Cyan - equations
                texts = equationTexts;
                color = '#00a8ff';
            } else if (sphereIndex === 1) { // Yellow - time
                texts = Array(8).fill(0).map(() => timeTexts());
                color = '#ffb62e';
            } else { // Magenta - manic
                texts = manicTexts;
                color = '#ff1e6e';
            }
            
            // Create burst of 5-8 particles
            const count = 5 + Math.floor(Math.random() * 4);
            for (let i = 0; i < count; i++) {
                const text = texts[Math.floor(Math.random() * texts.length)];
                createTextParticle(hitPos.x, hitPos.y, text, color, sphereIndex);
            }
        }
    });

    // --- Doorway input keyboard and click interaction ------------------------------------
    const promptContainer = document.querySelector('.prompt-container');
    const promptTextEl = document.getElementById('promptText');
    const promptCursorEl = document.getElementById('promptCursor');
    const promptEl = document.querySelector('.prompt');
    const hiddenInput = document.getElementById('hiddenInput');
    
    // Click to trigger CELLI glitch (reveal T) and focus hidden input for mobile
    if (promptContainer) {
        promptContainer.addEventListener('click', () => {
            if (!running || !doorwayOpened) return;
            if (!inputAttempted) {
                triggerCelliGlitch();
                inputAttempted = true;
            }

            // Focus hidden input for mobile keyboard
            if (hiddenInput) {
                hiddenInput.value = '';
                hiddenInput.focus();
            }
        });
        
        // Keyboard input to trigger final sequence (desktop)
        window.addEventListener('keydown', (e) => {
            if (!running || !doorwayOpened || !inputAttempted) return;

            if (e.key === 'Backspace') {
                e.preventDefault();
                handlePromptBackspace();
                return;
            }

            if (tEntered) return;

            // Only accept 'T' or 't' after clicking
            if (e.key.toLowerCase() === 't') {
                e.preventDefault();
                tEntered = true;
                inputText += 'T';

                refreshPromptDisplay();

                // Trigger burst animation
                setTimeout(() => {
                    triggerBurstToStars();
                }, 500);
            }
        });
        
        // Mobile input handler
        if (hiddenInput) {
            hiddenInput.addEventListener('keydown', (e) => {
                if (!running || !doorwayOpened || !inputAttempted) return;
                if (e.key === 'Backspace') {
                    e.preventDefault();
                    handlePromptBackspace();
                }
            });

            hiddenInput.addEventListener('input', (e) => {
                if (!running || !doorwayOpened || !inputAttempted || tEntered) return;

                const value = e.target.value.toUpperCase();
                if (value.includes('T')) {
                    e.preventDefault();
                    tEntered = true;
                    inputText += 'T';

                    refreshPromptDisplay();

                    // Blur input
                    hiddenInput.blur();

                    // Trigger burst animation
                    setTimeout(() => {
                        triggerBurstToStars();
                    }, 500);
                }
            });
        }

        if (!quoteLookWrap.classList.contains('quote__lookWrap--hidden')) {
            requestAnimationFrame(captureLookAnchorPosition);
        } else {
            updateLoomworksOffset();
        }
    }
    
    // Break apart and rise to sky
    let breakApartStarted = false;
    let riseStartTime = 0;
    
    function triggerBurstToStars() {
        if (burstAnimStarted) return;
        burstAnimStarted = true;
        breakApartStarted = true;
        riseStartTime = Date.now();
        
        // Increase afterimage effect for dramatic trails
        afterimagePass.uniforms.damp.value = 0.88;
        
        // Hide prompt but keep it for reference
        if (promptEl) {
            promptEl.style.transition = 'opacity 0.5s ease';
            promptEl.style.opacity = '0';
        }
        
        // Get only the T-shape voxels (the ones that weren't glitched)
        const activeVoxels = voxels.filter(v => !v.userData.glitched && v.visible);
        
        // Give each voxel velocity to shoot upward dramatically
        activeVoxels.forEach((voxel, idx) => {
            setTimeout(() => {
                const angle = Math.random() * Math.PI * 2;
                const spreadH = 0.008 + Math.random() * 0.015; // More horizontal spread
                
                voxel.userData.floating = true;
                voxel.userData.vx = Math.cos(angle) * spreadH;
                voxel.userData.vy = 0.08 + Math.random() * 0.05; // MUCH faster upward - shooting motion
                voxel.userData.vz = -0.05 - Math.random() * 0.08; // Move away from camera (into distance)
                voxel.userData.pulsatePhase = Math.random() * Math.PI * 2;
                voxel.userData.pulsateSpeed = 3 + Math.random() * 3;
                voxel.userData.floatStartTime = Date.now();
                voxel.userData.initialScale = voxel.userData.baseScale || 1.0;
            }, idx * 15); // Faster stagger
        });
        
        // Start camera pan after voxels have shot into distance
        setTimeout(() => {
            startCameraPan();
        }, 4000); // Slightly longer to see them recede
    }
    
    // Update floating voxels
    function updateFloatingVoxels(dt) {
        if (!breakApartStarted) return;
        
        const now = Date.now();
        const totalElapsed = (now - riseStartTime) / 1000;
        
        voxels.forEach(voxel => {
            if (!voxel.userData.floating) return;
            
            const data = voxel.userData;
            const age = (now - data.floatStartTime) / 1000;
            
            // Move with velocity - shooting into distance
            voxel.position.x += data.vx;
            voxel.position.y += data.vy;
            voxel.position.z += data.vz;
            
            // Very slow drag to maintain shooting motion
            data.vx *= 0.985;
            data.vy *= 0.985;
            data.vz *= 0.985;
            
            // Scale down dramatically as they move away (perspective)
            // Based on Z distance from camera
            const distanceZ = Math.abs(voxel.position.z + 0.5); // Initial Z was around -0.5
            const perspectiveScale = 1 / (1 + distanceZ * 3); // Shrink rapidly with distance
            
            // Pulsate on top of perspective scaling
            data.pulsatePhase += data.pulsateSpeed * dt;
            const pulse = 0.85 + Math.sin(data.pulsatePhase) * 0.15;
            const baseScale = data.initialScale || 1.0;
            const finalScale = baseScale * pulse * perspectiveScale;
            voxel.scale.set(finalScale, finalScale, finalScale);
            
            // Brighten voxels during shooting (they're stars now)
            voxel.material.color.setRGB(1, 1, 1); // Pure white
            
            // Pulsate material opacity with distance fade
            const opacityPulse = 0.8 + Math.sin(data.pulsatePhase * 0.7) * 0.2;
            const distanceFade = Math.max(0.3, 1 - distanceZ * 0.4); // Fade as they get far
            voxel.material.opacity = Math.min(1.0, opacityPulse * distanceFade);
            data.edges.material.opacity = Math.min(0.8, opacityPulse * 0.8 * distanceFade);
            
            // Fade out during camera pan
            if (cameraPanStarted) {
                const panProgress = (now - panStartTime) / panDuration;
                const fadeStart = 0.5;
                if (panProgress > fadeStart) {
                    const fadeProgress = (panProgress - fadeStart) / (1 - fadeStart);
                    voxel.material.opacity *= (1 - fadeProgress * 0.8);
                    data.edges.material.opacity *= (1 - fadeProgress * 0.8);
                }
            }
        });
    }
    
    // Pan camera down to reveal gradient
    let cameraPanStarted = false;
    let panStartTime = 0;
    const panDuration = 5000; // 5 seconds for dramatic reveal
    
    function startCameraPan() {
        cameraPanStarted = true;
        panStartTime = Date.now();
    }
    
    function updateCameraPan() {
        if (!cameraPanStarted) return;
        
        const elapsed = Date.now() - panStartTime;
        const progress = Math.min(1, elapsed / panDuration);
        
        // Smooth ease-in-out for dramatic pan
        const eased = progress < 0.5 ? 
            2 * progress * progress : 
            1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        // Gradually reduce afterimage effect during pan to fade trails
        afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.88, 0.96, progress);
        
        // Pan down much further to reveal gradient
        camera.position.y = THREE.MathUtils.lerp(0, -5, eased);
        camera.lookAt(0, camera.position.y - 2, 0); // Look ahead of camera position
        
        // Fade doorway, prompt, and vignette quickly
        const doorway = document.getElementById('doorway');
        if (doorway) {
            doorway.style.opacity = Math.max(0, 1 - progress * 2);
        }
        
        // Fade out vignette
        const vignette = document.querySelector('.vignette');
        if (vignette) {
            vignette.style.transition = 'opacity 1s ease';
            vignette.style.opacity = String(Math.max(0, 1 - progress * 1.5));
        }
        
        // Add blue gradient background early in the pan
        if (progress > 0.2 && !document.getElementById('nightSky')) {
            // Set app background to black initially for smooth transition
            const app = document.getElementById('app');
            if (app) {
                app.style.background = '#000';
            }
            
            // Immediately hide vignette and scanlines when gradient appears
            const vignetteEl = document.querySelector('.vignette');
            if (vignetteEl) {
                vignetteEl.style.display = 'none';
            }
            
            // Hide scanlines overlay
            if (app && app.classList.contains('scanlines')) {
                app.classList.add('fade-scanlines');
            }
            
            const nightSky = document.createElement('div');
            nightSky.id = 'nightSky';
            nightSky.style.position = 'fixed';
            nightSky.style.inset = '0';
            nightSky.style.background = 'linear-gradient(to bottom, #0d1b2a 0%, #1a237e 20%, #283593 40%, #3949ab 60%, #5e92f3 80%, #90caf9 100%)';
            nightSky.style.zIndex = '0';
            nightSky.style.opacity = '0';
            nightSky.style.pointerEvents = 'none';
            
            // Insert at beginning of body
            if (document.body.firstChild) {
                document.body.insertBefore(nightSky, document.body.firstChild);
            } else {
                document.body.appendChild(nightSky);
            }
            
            // Fade in gradient
            setTimeout(() => {
                nightSky.style.transition = 'opacity 3s ease';
                nightSky.style.opacity = '1';
                
                // Fade out black background
                if (app) {
                    app.style.transition = 'background 3s ease';
                    app.style.background = 'transparent';
                }
            }, 100);
        }
        
        // Fade out 3D scene elements as gradient appears
        if (progress > 0.3) {
            const fadeAmount = Math.min(1, (progress - 0.3) / 0.7); // Fade from 30% to 100%
            
            // Fade renderer canvas
            renderer.domElement.style.transition = 'opacity 0.5s ease';
            renderer.domElement.style.opacity = String(1 - fadeAmount * 0.8); // Keep slight visibility
        }
        
        // Keep stars visible over the gradient longer
        if (progress > 0.7) {
            const starFade = (progress - 0.7) / 0.3;
            textCanvas.style.opacity = String(1 - starFade);
        }
    }
    
    // Render star particles
    function renderStars() {
        if (starParticles.length === 0) return;
        
        const now = Date.now();
        
        // Update and render each star
        for (let i = starParticles.length - 1; i >= 0; i--) {
            const star = starParticles[i];
            
            // Update position based on velocity
            if (star.vx !== undefined) {
                star.x += star.vx;
                star.y += star.vy;
                star.z += star.vz;
                
                // Very slow drag to keep stars moving
                star.vx *= 0.995;
                star.vy *= 0.995;
                star.vz *= 0.995;
            }
            
            // Calculate age and fade
            const age = (now - star.birthTime) / 1000; // in seconds
            const fadeDuration = 8; // fade over 8 seconds (much slower)
            const fadeProgress = Math.min(1, age / fadeDuration);
            
            // Dim brightness over time - keep them bright longer
            star.brightness = 1 - fadeProgress * 0.5; // Keep 50% minimum
            
            // Update twinkle
            star.twinkle += star.twinkleSpeed * 0.016;
            const twinkleBrightness = 0.8 + Math.sin(star.twinkle) * 0.2;
            const finalBrightness = star.brightness * twinkleBrightness;
            
            // Keep stars visible much longer - only remove when very faint
            if (finalBrightness < 0.05) {
                starParticles.splice(i, 1);
                continue;
            }
            
            // Project to screen space
            const vector = new THREE.Vector3(star.x, star.y, star.z);
            vector.project(camera);
            
            // Check if behind camera
            if (vector.z > 1) continue;
            
            const x = (vector.x + 1) / 2 * window.innerWidth;
            const y = (-vector.y + 1) / 2 * window.innerHeight;
            
            // Size based on distance (z-depth)
            const depthScale = Math.max(0.5, 1 - vector.z * 0.5);
            const renderSize = star.size * window.innerWidth * 0.01 * depthScale;
            
            // Draw voxel as square with slight glow
            const voxelSize = renderSize * 1.5;
            const glowSize = voxelSize * 1.5;
            
            // Outer glow
            const gradient = textCtx.createRadialGradient(x, y, 0, x, y, glowSize);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${finalBrightness * 0.8})`);
            gradient.addColorStop(0.6, `rgba(255, 255, 255, ${finalBrightness * 0.3})`);
            gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
            textCtx.fillStyle = gradient;
            textCtx.beginPath();
            textCtx.arc(x, y, glowSize, 0, Math.PI * 2);
            textCtx.fill();
            
            // Core voxel - square shape
            textCtx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, finalBrightness * 1.1)})`;
            textCtx.fillRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);
            
            // Subtle border for voxel definition
            if (finalBrightness > 0.5) {
                textCtx.strokeStyle = `rgba(255, 255, 255, ${finalBrightness * 0.6})`;
                textCtx.lineWidth = 0.5;
                textCtx.strokeRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);
            }
        }
    }

    // --- Play button wiring -------------------------------------------------
    const playOverlay = document.getElementById('play');
    playBtn.addEventListener('click', ()=>{
      running = true; clock.getDelta();
      playOverlay.classList.add('hidden');
      clearToast();
      frame();
    });

    // --- Bring-up Self‑Tests & Toast ---------------------------------------
    (function bootDiagnostics(){
      const meshes = scene.children.filter(o=>o.isMesh).length;
      const lines = [ `Meshes: ${meshes}`, `Hint: press Play to start animation` ];
      toast(lines,'ok');
      if(meshes!==5) toast([`Expected 5 meshes (3 spheres + 1 hole + 1 tri), got ${meshes}`],'warn');
    })();
  </script>
</body>
</html>




